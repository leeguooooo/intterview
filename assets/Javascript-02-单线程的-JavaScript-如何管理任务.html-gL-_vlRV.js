import{_ as e,c as s,o as n,a}from"./app-DVMZDNEl.js";const p="/images/s_poetries_work_images_20210719144617.png",i="/images/s_poetries_work_images_20210719145333.png",t="/images/s_poetries_work_images_20210719145944.png",l={},o=a('<p>原文链接: <a href="https://interview.poetries.top/principle-docs/js/02-%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%20JavaScript%20%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1.html" target="_blank" rel="noopener noreferrer">https://interview.poetries.top/principle-docs/js/02-%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%20JavaScript%20%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1.html</a></p><p>要怎么理解 JavaScript 是单线程这个概念呢？大概需要从浏览器来说起。</p><p>JavaScript 最初被设计为浏览器脚本语言，主要用途包括对页面的操作、与浏览器的交互、与用户的交互、页面逻辑处理等。如果将 JavaScript 设计为多线程，那当多个线程同时对同一个 DOM 节点进行操作时，线程间的同步问题会变得很复杂。</p><p>因此，为了避免复杂性，JavaScript 被设计为单线程。</p><p>这样一个单线程的 JavaScript，意味着任务需要一个接一个地处理。如果有一个任务是等待用户输入，那在用户进行操作前，所有其他任务都处于等待状态，页面会进入假死状态，用户体验会很糟糕。</p><p>那么，为了高效进行页面的交互和渲染处理，我们围绕着任务执行是否阻塞 JavaScript 主线程，将 JavaScript 中的任务分为同步任务和异步任务</p><h2 id="同步任务与异步任务" tabindex="-1"><a class="header-anchor" href="#同步任务与异步任务"><span>同步任务与异步任务</span></a></h2><ul><li>同步任务：在主线程上排队执行的任务，前一个任务完整地执行完成后，后一个任务才会被执行</li><li>异步任务：不会阻塞主线程，在其任务执行完成之后，会再根据一定的规则去执行相关的回调。</li></ul><p>我们先来看一下同步任务在浏览器中的是怎样执行的。</p><h2 id="同步任务与函数调用栈" tabindex="-1"><a class="header-anchor" href="#同步任务与函数调用栈"><span>同步任务与函数调用栈</span></a></h2><p>JavaScript 在执行过程中每进入一个不同的运行环境时，都会创建一个相应的执行上下文。那么，当我们执行一段 JavaScript 代码时，通常会创建多个执行上下文。</p><p>而 JavaScript 解释器会以栈的方式管理这些执行上下文、以及函数之间的调用关系，形成函数调用栈（call stack）（调用栈可理解为一个存储函数调用的栈结构，遵循 FILO（先进后出）的原则）</p><p><strong>我们来看一下 JavaScript 中代码执行的过程：</strong></p><ul><li>首先进入全局环境，全局执行上下文被创建并添加进栈中；</li><li>每调用一个函数，该函数执行上下文会被添加进调用栈，并开始执行；</li><li>如果正在调用栈中执行的 A 函数还调用了 B 函数，那么 B 函数也将会被添加进调用栈；</li><li>一旦 B 函数被调用，便会立即执行；</li><li>当前函数执行完毕后，JavaScript 解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。</li></ul><blockquote><p>由此可见，JavaScript 代码执行过程中，函数调用栈栈底永远是全局执行上下文，栈顶永远是当前执行上下文。</p></blockquote><p>在不考虑全局执行上下文时，我们可以理解为刚开始的时候调用栈是空的，每当有函数被调用，相应的执行上下文都会被添加到调用栈中。执行完函数中相关代码后，该执行上下文又会自动被调用栈移除，最后调用栈又回到了空的状态（同样不考虑全局执行上下文）。</p><p>由于栈的容量是有限制的，所以当我们没有合理调用函数的时候，可能会导致爆栈异常，此时控制台便会抛出错误：</p><p><img src="'+p+'" alt=""></p><p>这样的一个函数调用栈结构，可以理解为 JavaScript 中同步任务的执行环境，同步任务也可以理解为 JavaScript 代码片段的执行。</p><p>同步任务的执行会阻塞主线程，也就是说，一个函数执行的时候不会被抢占，只有在它执行完毕之后，才会去执行任何其他的代码。这意味着如果我们一个任务执行的时间过长，浏览器就无法处理与用户的交互，例如点击或滚动。</p><p>因此，我们还需要用到异步任务。</p><h2 id="异步任务与回调队列" tabindex="-1"><a class="header-anchor" href="#异步任务与回调队列"><span>异步任务与回调队列</span></a></h2><p>异步任务包括一些需要等待响应的任务，包括用户交互、HTTP 请求、定时器等。</p><p>我们知道，I/O 类型的任务会有较长的等待时间，对于这类无法立刻得到结果的事件，可以使用异步任务的方式。这个过程中 JavaScript 线程就不用处于等待状态，CPU 也可以处理其他任务。</p><p>异步任务需要提供回调函数，当异步任务有了运行结果之后，该任务则会被添加到回调队列中，主线程在适当的时候会从回调队列中取出相应的回调函数并执行。</p><p>这里提到的回调队列又是什么呢？</p><p>实际上，JavaScript 在运行的时候，除了函数调用栈之外，还包含了一个待处理的回调队列。在回调队列中的都是已经有了运行结果的异步任务，每一个异步任务都会关联着一个回调函数。</p><p>回调队列则遵循 FIFO（先进先出）的原则，JavaScript 执行代码过程中，会进行以下的处理：</p><ul><li>运行时，会从最先进入队列的任务开始，处理队列中的任务；</li><li>被处理的任务会被移出队列，该任务的运行结果会作为输入参数，并调用与之关联的函数，此时会产生一个函数调用栈；</li><li>函数会一直处理到调用栈再次为空，然后 Event Loop 将会处理队列中的下一个任务。</li></ul><p>这里我们提到了 Event Loop，它主要是用来管理单线程的 JavaScript 中同步任务和异步任务的执行问题。</p><h2 id="单线程的-javascript-是如何管理任务的" tabindex="-1"><a class="header-anchor" href="#单线程的-javascript-是如何管理任务的"><span>单线程的 JavaScript 是如何管理任务的</span></a></h2><p>我们知道，单线程的设计会存在阻塞问题，为此 JavaScript 中任务被分为同步和异步任务。那么，同步任务和异步任务之间是按照什么顺序来执行的呢？</p><p>JavaScript 有一个基于事件循环的并发模型，称为事件循环（Event Loop），它的设计解决了同步任务和异步任务的管理问题。</p><p>根据 JavaScript 运行环境的不同，Event Loop 也会被分成浏览器的 <code>Event Loop</code> 和 Node.js 中的 Event Loop。</p><h2 id="浏览器的-event-loop" tabindex="-1"><a class="header-anchor" href="#浏览器的-event-loop"><span>浏览器的 Event Loop</span></a></h2><p>在浏览器里，每当一个被监听的事件发生时，事件监听器绑定的相关任务就会被添加进回调队列。通过事件产生的任务是异步任务，常见的事件任务包括：</p><ul><li>用户交互事件产生的事件任务，比如输入操作；</li><li>计时器产生的事件任务，比如setTimeout；</li><li>异步请求产生的事件任务，比如 HTTP 请求。</li></ul><p><img src="'+i+`" alt=""></p><p>如图，主线程运行的时候，会产生堆（heap）和栈（stack），其中堆为内存、栈为函数调用栈。我们能看到，Event Loop 负责执行代码、收集和处理事件以及执行队列中的子任务，具体包括以下过程</p><ul><li>JavaScript 有一个主线程和调用栈，所有的任务最终都会被放到调用栈等待主线程执行。</li><li>同步任务会被放在调用栈中，按照顺序等待主线程依次执行。</li><li>主线程之外存在一个回调队列，回调队列中的异步任务最终会在主线程中以调用栈的方式运行。</li><li>同步任务都在主线程上执行，栈中代码在执行的时候会调用浏览器的 API，此时会产生一些异步任务。</li><li>异步任务会在有了结果（比如被监听的事件发生时）后，将异步任务以及关联的回调函数放入回调队列中。</li><li>调用栈中任务执行完毕后，此时主线程处于空闲状态，会从回调队列中获取任务进行处理。</li></ul><p>上述过程会不断重复，这就是 JavaScript 的运行机制，称为事件循环机制（Event Loop）。</p><p>Event Loop 的设计会带来一些问题，比如setTimeout、setInterval的时间精确性。这两个方法会设置一个计时器，当计时器计时完成，需要执行回调函数，此时才把回调函数放入回调队列中。</p><p>如果当回调函数放入队列时，假设队列中还有大量的回调函数在等待执行，此时就会造成任务执行时间不精确。</p><p>要优化这个问题，可以使用系统时钟来补偿计时器的不准确性，从而提升精确度。举个例子，如果你的计时器会在回调时触发二次计时，可以在每次回调任务结束的时候，根据最初的系统时间和该任务的执行时间进行差值比较，来修正后续的计时器时间。</p><h2 id="node-js-中的-event-loop" tabindex="-1"><a class="header-anchor" href="#node-js-中的-event-loop"><span>Node.js 中的 Event Loop</span></a></h2><p>除了浏览器，Node.js 中同样存在 Event Loop。由于 JavaScript 是单线程的，Event Loop 的设计使 Node.js 可以通过将操作转移到系统内核中，来执行非阻塞 I/O 操作</p><p><strong>Node.js 中的事件循环执行过程为：</strong></p><ul><li>当 Node.js 启动时将初始化事件循环，处理提供的输入脚本；</li><li>提供的输入脚本可以进行异步 API 调用，然后开始处理事件循环；</li><li>在事件循环的每次运行之间，Node.js 会检查它是否正在等待任何异步 <code>I/O</code> 或计时器，如果没有，则将其干净地关闭</li></ul><p>与浏览器不一样，Node.js 中事件循环分成不同的阶段：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">       ┌───────────────────────────┐</span>
<span class="line">    </span>
<span class="line">    ┌─<span class="token operator">&gt;</span>│           timers          │</span>
<span class="line">    </span>
<span class="line">    │  └─────────────┬─────────────┘</span>
<span class="line">    </span>
<span class="line">    │  ┌─────────────┴─────────────┐</span>
<span class="line">    </span>
<span class="line">    │  │     pending callbacks     │</span>
<span class="line">    </span>
<span class="line">    │  └─────────────┬─────────────┘</span>
<span class="line">    </span>
<span class="line">    │  ┌─────────────┴─────────────┐</span>
<span class="line">    </span>
<span class="line">    │  │       idle<span class="token punctuation">,</span> prepare       │</span>
<span class="line">    </span>
<span class="line">    │  └─────────────┬─────────────┘      ┌───────────────┐</span>
<span class="line">    </span>
<span class="line">    │  ┌─────────────┴─────────────┐      │   incoming<span class="token operator">:</span>   │</span>
<span class="line">    </span>
<span class="line">    │  │           poll            │<span class="token operator">&lt;</span>─────┤               <span class="token operator">|</span></span>
<span class="line">    </span>
<span class="line">    │  └─────────────┬─────────────┘      │   data<span class="token punctuation">,</span> etc<span class="token punctuation">.</span>  │</span>
<span class="line">    </span>
<span class="line">    │  ┌─────────────┴─────────────┐      └───────────────┘</span>
<span class="line">    </span>
<span class="line">    │  │           check           │</span>
<span class="line">    </span>
<span class="line">    │  └─────────────┬─────────────┘</span>
<span class="line">    </span>
<span class="line">    │  ┌─────────────┴─────────────┐</span>
<span class="line">    </span>
<span class="line">    └──┤      close callbacks      │</span>
<span class="line">    </span>
<span class="line">       └───────────────────────────┘</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+t+'" alt=""></p><p>由于事件循环阶段划分不一致，Node.js 和浏览器在对宏任务和微任务的处理上也不一样</p><h2 id="宏任务和微任务" tabindex="-1"><a class="header-anchor" href="#宏任务和微任务"><span>宏任务和微任务</span></a></h2><p>事件循环中的异步回调队列有两种：宏任务（MacroTask）和微任务（MicroTask）队列。</p><p>什么是宏任务和微任务呢？</p><ul><li>宏任务：包括 script 全部代码、setTimeout、setInterval、setImmediate（Node.js）、requestAnimationFrame（浏览器）、I/O 操作、UI 渲染（浏览器），这些代码执行便是宏任务。</li><li>微任务：包括<code>process.nextTick</code>（Node.js）、<code>Promise</code>、<code>MutationObserver</code>，这些代码执行便是微任务</li></ul><blockquote><p>为什么要将异步任务分为宏任务和微任务呢？这是为了避免回调队列中等待执行的异步任务（宏任务）过多，导致某些异步任务（微任务）的等待时间过长。在每个宏任务执行完成之后，会先将微任务队列中的任务执行完毕，再执行下一个宏任务</p></blockquote><p><strong>在浏览器的异步回调队列中，宏任务和微任务的执行过程如下：</strong></p><ul><li>宏任务队列一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务。</li><li>微任务队列中所有的任务都会被依次取出来执行，直到微任务队列为空。</li><li>在执行完所有的微任务之后，执行下一个宏任务之前，浏览器会执行 UI 渲染操作、更新界面。</li></ul><p>我们能看到，在浏览器中每个宏任务执行完成后，会执行微任务队列中的任务。而在 Node.js 中，事件循环分为 6 个阶段，微任务会在事件循环的各个阶段之间执行。也就是说，每当一个阶段执行完毕，就会去执行微任务队列的任务</p><p>``js console.log(&quot;script start&quot;);</p><p>setTimeout(() =&gt; {</p><p>console.log(&quot;setTimeout&quot;);</p><p>}, 1000);</p><p>Promise.resolve()</p><p>.then(function () {</p><p>console.log(&quot;promise1&quot;);</p><p>})</p><p>.then(function () {</p><p>console.log(&quot;promise2&quot;);</p><p>});</p><p>async function errorFunc() {</p><p>try {</p><p>await Promise.reject(&quot;error!!!&quot;);</p><p>} catch (e) {</p><p>console.log(&quot;error caught&quot;); // 微1-3</p><p>}</p><p>console.log(&quot;errorFunc&quot;);</p><p>return Promise.resolve(&quot;errorFunc success&quot;);</p><p>}</p><p>errorFunc().then((res) =&gt; console.log(&quot;errorFunc then res&quot;));</p><p>console.log(&quot;script end&quot;);</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">    <span class="token operator">&gt;</span> <span class="token operator">-</span> 在 Node<span class="token punctuation">.</span>js 中，事件循环分为 <span class="token number">6</span> 个阶段，微任务会在事件循环的各个阶段之间执行。也就是说，每当一个阶段执行完毕，就会去执行微任务队列的任务。 可以以文中的例子来试试看，在浏览器和 Node<span class="token punctuation">.</span>js 环境中的执行结果有什么不一样（当然，Node<span class="token punctuation">.</span>js <span class="token number">11</span> 版本之后，两个结果已经一致了）</span>\n<span class="line">    <span class="token operator">&gt;</span> <span class="token operator">-</span> 在 node <span class="token number">11</span> 之后的版本，的确是浏览器保持一致了<span class="token operator">~</span> 以 timers 阶段为例，在 node <span class="token number">11</span> 版本之前，只有全部执行了 timers 阶段队列的全部任务才执行微任务队列；在 node <span class="token number">11</span> 版本开始，timer 阶段的 setTimeout、setInterval 被修改为，执行一个任务就立刻执行微任务队列，与浏览器趋同了<span class="token operator">~</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>阅读全文</p>',84),r=[o];function c(d,v){return n(),s("div",null,r)}const m=e(l,[["render",c],["__file","Javascript-02-单线程的-JavaScript-如何管理任务.html.vue"]]),E=JSON.parse('{"path":"/Javascript-02-%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84-JavaScript-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1.html","title":"","lang":"zh-CN","frontmatter":{"description":"原文链接: https://interview.poetries.top/principle-docs/js/02-%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%20JavaScript%20%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1.html 要怎么理解 J...","head":[["meta",{"property":"og:url","content":"https://interview.leeguoo.com/Javascript-02-%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84-JavaScript-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1.html"}],["meta",{"property":"og:site_name","content":"前端面试题集锦"}],["meta",{"property":"og:description","content":"原文链接: https://interview.poetries.top/principle-docs/js/02-%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%20JavaScript%20%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1.html 要怎么理解 J..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://interview.leeguoo.com/images/s_poetries_work_images_20210719144617.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-06T05:59:31.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-06T05:59:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210719144617.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210719145333.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210719145944.png\\"],\\"dateModified\\":\\"2024-06-06T05:59:31.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"同步任务与异步任务","slug":"同步任务与异步任务","link":"#同步任务与异步任务","children":[]},{"level":2,"title":"同步任务与函数调用栈","slug":"同步任务与函数调用栈","link":"#同步任务与函数调用栈","children":[]},{"level":2,"title":"异步任务与回调队列","slug":"异步任务与回调队列","link":"#异步任务与回调队列","children":[]},{"level":2,"title":"单线程的 JavaScript 是如何管理任务的","slug":"单线程的-javascript-是如何管理任务的","link":"#单线程的-javascript-是如何管理任务的","children":[]},{"level":2,"title":"浏览器的 Event Loop","slug":"浏览器的-event-loop","link":"#浏览器的-event-loop","children":[]},{"level":2,"title":"Node.js 中的 Event Loop","slug":"node-js-中的-event-loop","link":"#node-js-中的-event-loop","children":[]},{"level":2,"title":"宏任务和微任务","slug":"宏任务和微任务","link":"#宏任务和微任务","children":[]}],"git":{"updatedTime":1717653571000,"contributors":[{"name":"guoli","email":"guoli@zhihu.com","commits":1}]},"autoDesc":true,"filePathRelative":"Javascript-02-单线程的-JavaScript-如何管理任务.md","excerpt":"<p>原文链接: <a href=\\"https://interview.poetries.top/principle-docs/js/02-%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%20JavaScript%20%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://interview.poetries.top/principle-docs/js/02-%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%20JavaScript%20%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1.html</a></p>"}');export{m as comp,E as data};
