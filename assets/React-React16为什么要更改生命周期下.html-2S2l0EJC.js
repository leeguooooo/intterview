import{_ as n,c as s,o as a,a as e}from"./app-f2Cpj3V4.js";const t="/images/s_poetries_work_images_20210428184607.png",p="/images/s_poetries_work_images_20210428184635.png",o="/images/s_poetries_work_images_20210428172751.png",c="/images/s_poetries_work_images_20210428172830.png",l="/images/s_poetries_work_images_20210428183642.png",i="/images/s_poetries_work_images_20210428183744.png",r="/images/s_poetries_work_images_20210428183909.png",u="/images/s_poetries_work_images_20210428184212.png",d="/images/s_poetries_work_images_20210428185041.png",k="/images/s_poetries_work_images_20210428185206.png",m="/images/s_poetries_work_images_20210428190634.png",v="/images/s_poetries_work_images_20210428191042.png",g="/images/s_poetries_work_images_20210428191428.png",b="/images/s_poetries_work_images_20210428191535.png",h="/images/s_poetries_work_images_20210428191629.png",_={},B=e('<p>原文链接: <a href="https://interview.poetries.top/principle-docs/react/12-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8B.html" target="_blank" rel="noopener noreferrer">https://interview.poetries.top/principle-docs/react/12-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8B.html</a></p><h2 id="进化的生命周期方法-react-16-生命周期工作流详解" tabindex="-1"><a class="header-anchor" href="#进化的生命周期方法-react-16-生命周期工作流详解"><span>进化的生命周期方法：React 16 生命周期工作流详解</span></a></h2><blockquote><p>来源于：<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram" target="_blank" rel="noopener noreferrer">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram</a><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram" target="_blank" rel="noopener noreferrer"> (opens new window)</a></p></blockquote><p><img src="'+t+'" alt=""></p><blockquote><p>在React 16.4之后，React 生命周期在之前版本的基础上又经历了一次微调，其实就调在了更新过程的<code>getDerivedStateFromProps</code> 这个生命周期上</p></blockquote><p><img src="'+p+`" alt=""></p><p>这里我先提供一个 Demo，它将辅助你理解新的生命周期。Demo 代码如下</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">&quot;react-dom&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 定义子组件</span></span>
<span class="line">    <span class="token keyword">class</span> <span class="token class-name">LifeCycle</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;进入constructor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// state 可以在 constructor 里初始化</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&quot;子组件的文本&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token comment">// 初始化/更新时调用</span></span>
<span class="line">      <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;getDerivedStateFromProps方法执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token punctuation">{</span></span>
<span class="line">          <span class="token literal-property property">fatherText</span><span class="token operator">:</span> props<span class="token punctuation">.</span>text</span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token comment">// 初始化渲染时调用</span></span>
<span class="line">      <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;componentDidMount方法执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token comment">// 组件更新时调用</span></span>
<span class="line">      <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;shouldComponentUpdate方法执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 组件更新时调用</span></span>
<span class="line">      <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;getSnapshotBeforeUpdate方法执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token string">&quot;haha&quot;</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token comment">// 组件更新后调用</span></span>
<span class="line">      <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">preProps<span class="token punctuation">,</span> preState<span class="token punctuation">,</span> valueFromSnapshot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;componentDidUpdate方法执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;从 getSnapshotBeforeUpdate 获取到的值是&quot;</span><span class="token punctuation">,</span> valueFromSnapshot<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token comment">// 组件卸载时调用</span></span>
<span class="line">      <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;子组件的componentWillUnmount方法执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token comment">// 点击按钮，修改子组件文本内容的方法</span></span>
<span class="line">      <span class="token function-variable function">changeText</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">          <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&quot;修改后的子组件文本&quot;</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;render方法执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">          <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>changeText<span class="token punctuation">}</span> className<span class="token operator">=</span><span class="token string">&quot;changeText&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">              修改子组件文本内容</span>
<span class="line">            <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span>p className<span class="token operator">=</span><span class="token string">&quot;textContent&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>text<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span>p className<span class="token operator">=</span><span class="token string">&quot;fatherContent&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>text<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span></span>
<span class="line">          <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line">        <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token comment">// 定义 LifeCycle 组件的父组件</span></span>
<span class="line">    <span class="token keyword">class</span> <span class="token class-name">LifeCycleContainer</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// state 也可以像这样用属性声明的形式初始化</span></span>
<span class="line">      state <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&quot;父组件的文本&quot;</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token literal-property property">hideChild</span><span class="token operator">:</span> <span class="token boolean">false</span></span>
<span class="line">      <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token comment">// 点击按钮，修改父组件文本的方法</span></span>
<span class="line">      <span class="token function-variable function">changeText</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">          <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&quot;修改后的父组件文本&quot;</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token comment">// 点击按钮，隐藏（卸载）LifeCycle 组件的方法</span></span>
<span class="line">      <span class="token function-variable function">hideChild</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">          <span class="token literal-property property">hideChild</span><span class="token operator">:</span> <span class="token boolean">true</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">          <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;fatherContainer&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>changeText<span class="token punctuation">}</span> className<span class="token operator">=</span><span class="token string">&quot;changeText&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">              修改父组件文本内容</span>
<span class="line">            <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>hideChild<span class="token punctuation">}</span> className<span class="token operator">=</span><span class="token string">&quot;hideChild&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">              隐藏子组件</span>
<span class="line">            <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span></span>
<span class="line">            <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>hideChild <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token operator">&lt;</span>LifeCycle text<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>text<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">}</span></span>
<span class="line">          <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line">        <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>LifeCycleContainer <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 16 以来的生命周期也可以按照“挂载”“更新”和“卸载”三个阶段来看，所以接下来我们要做的事情仍然是分阶段拆解工作流程。</p><h2 id="mounting-阶段-组件的初始化渲染-挂载" tabindex="-1"><a class="header-anchor" href="#mounting-阶段-组件的初始化渲染-挂载"><span><code>Mounting 阶段</code>：组件的初始化渲染（挂载）</span></a></h2><p>为了凸显 16 和 15 两个版本生命周期之间的差异，我将两个流程绘制到了同一张大图里，请看下面这张图：</p><p><img src="`+o+'" alt=""></p><p>运行示例代码</p><p><img src="'+c+'" alt=""></p><p><strong>消失的 componentWillMount，新增的 getDerivedStateFromProps</strong></p><p>从上图中不难看出，<code>React 15</code> 生命周期和 <code>React 16.3</code> 生命周期在<strong>挂载阶段的主要差异在于</strong> ，<code>废弃了 componentWillMount，新增了 getDerivedStateFromProps</code></p><blockquote><p>注：细心的你可能记得，<code>React 16 对 render 方法也进行了一些改进</code>。React 16 之前，<code>render方法必须返回单个元素</code>，而 React 16 <code>允许我们返回元素数组和字符串</code></p></blockquote><p><strong>getDerivedStateFromProps 不是 componentWillMount 的替代品</strong></p><blockquote><p>事实上，<code>componentWillMount</code> 的存在不仅“鸡肋”而且危险，因此它并不值得被“代替”，它就应该被废弃</p></blockquote><ul><li>而 <code>getDerivedStateFromProps</code> 这个 API，其设计的初衷不是试图替换掉 <code>componentWillMount</code>，而是试图替换<code>componentWillReceiveProps</code>，因此它有且仅有一个用途：<code>使用 props 来派生/更新 state</code></li><li>React 团队为了确保 <code>getDerivedStateFromProps</code> 这个生命周期的纯洁性，直接从命名层面约束了它的用途（<code>getDerivedStateFromProps</code> 直译过来就是“<code>从 Props 里派生 State</code>”）。所以，如果你不是出于这个目的来使用 <code>getDerivedStateFromProps</code>，原则上来说都是不符合规范的</li></ul><blockquote><p>值得一提的是，<code>getDerivedStateFromProps</code> 在<code>更新和挂载两个阶段</code>都会“出镜”（这点不同于仅在更新阶段出现的 <code>componentWillReceiveProps</code>）。这是因为“派生 state”这种诉求不仅在 <code>props</code> 更新时存在，在 <code>props</code> 初始化的时候也是存在的</p></blockquote><p><strong>认识 getDerivedStateFromProps</strong></p><p>这个新生命周期方法的调用规则如下：<code>static getDerivedStateFromProps(props, state)</code></p><p>在使用层面，你需要把握三个重点。</p><p><strong>第一个重点是最特别的一点</strong> ：<code>getDerivedStateFromProps</code> 是一个静态方法。静态方法不依赖组件实例而存在，因此你在这个方法内部是访问不到 <code>this</code> 的。若你偏要尝试这样做，必定报错，报错形式如下图所示：</p><p><img src="'+l+'" alt=""></p><p><strong>第二个重点，该方法可以接收两个参数：props 和 state</strong> ，它们分别代表当前组件接收到的来自父组件的 <code>props</code> 和当前组件自身的 <code>state</code>。我们可以尝试在 Demo 中输出这两个参数看一看，输出效果如下图所示：</p><p><img src="'+i+'" alt=""></p><p>可以看出，挂载阶段输出的 <code>props</code> 正是初始化阶段父组件传进来的 <code>this.props</code> 对象；而 <code>state</code> 是 <code>LifeCycle</code> 组件自身的 <code>state</code> 对象</p><p><strong>第三个重点，getDerivedStateFromProps 需要一个对象格式的返回值</strong> 。如果你没有指定这个返回值，那么大概率会被 React 警告一番，警告内容如下图所示：</p><p><img src="'+r+`" alt=""></p><blockquote><p><code>getDerivedStateFromProps</code> 的返回值之所以不可或缺，是因为 React 需要用这个返回值来更新（派生）组件的 <code>state</code>。因此当你确实不存在“使用 <code>props 派生 state</code> ”这个需求的时候，最好是直接省略掉这个生命周期方法的编写，否则一定记得给它 <code>return</code> 一个 <code>null</code></p></blockquote><p>注意，<code>getDerivedStateFromProps</code> 方法对 <code>state</code> 的更新动作并非“覆盖”式的更新，而是针对某个属性的定向更新。比如这里我们在 <code>getDerivedStateFromProps</code> 里返回的是这样一个对象，对象里面有一个 <code>fatherText</code> 属性用于表示“父组件赋予的文本”：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token punctuation">{</span></span>
<span class="line">      <span class="token literal-property property">fatherText</span><span class="token operator">:</span> props<span class="token punctuation">.</span>text</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该对象并不会替换掉组件原始的这个 <code>state</code>：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&quot;子组件的文本&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>而是仅仅针对 <code>fatherText</code> 这个属性作更新（这里原有的 <code>state</code> 里没有 <code>fatherText</code>，因此直接新增）。更新后，原有属性与新属性是共存的，如下图所示</p></blockquote><p><img src="`+u+'" alt=""></p><h2 id="updating-阶段-组件的更新" tabindex="-1"><a class="header-anchor" href="#updating-阶段-组件的更新"><span>Updating 阶段：组件的更新</span></a></h2><p>React 15 与 React 16.3 的更新流程对比如下图所示：</p><p><img src="'+d+'" alt=""></p><blockquote><p><code>React 16.4</code> 对生命周期流程进行了“微调”，其实就调在了更新过程的 <code>getDerivedStateFromProps</code> 这个生命周期上</p></blockquote><p><img src="'+k+`" alt=""></p><p><code>React 16.4</code> 的挂载和卸载流程都是与 <code>React 16.3</code> 保持一致的，差异在于更新流程上：</p><ul><li>在 <code>React 16.4</code> 中，任何因素触发的组件更新流程（包括由 <code>this.setState</code> 和 <code>forceUpdate</code> 触发的更新流程）都会触发 <code>getDerivedStateFromProps</code>；</li><li>而在 <code>v 16.3</code> 版本时，<code>只有父组件的更新会触发该生命周期</code>。</li></ul><p>到这里，你已经对 <code>getDerivedStateFromProps</code> 相关的改变有了充分的了解。接下来，我们就基于这层了解，问出生命周期改变背后的第一个“Why”。</p><p><strong>1. 改变背后的第一个“Why”：为什么要用 getDerivedStateFromProps 代替 componentWillReceiveProps？</strong></p><p>对于 <code>getDerivedStateFromProps</code> 这个 API，React 官方曾经给出过这样的描述</p><blockquote><p>与 <code>componentDidUpdate</code> 一起，这个新的生命周期涵盖过时<code>componentWillReceiveProps</code> 的所有用例</p></blockquote><p>在这里，请你细细品味这句话，这句话里蕴含了下面两个关键信息：</p><ul><li><code>getDerivedStateFromProps</code> 是作为一个试图代替 <code>componentWillReceiveProps</code> 的 API 而出现的；</li><li><code>getDerivedStateFromProps</code> 不能完全和 <code>componentWillReceiveProps</code> 画等号，其特性决定了我们曾经在 <code>componentWillReceiveProps</code> 里面做的事情，不能够百分百迁移到<code>getDerivedStateFromProps</code> 里。</li></ul><p>接下来我们就展开说说这两点。</p><ul><li>关于 <code>getDerivedStateFromProps</code> 是如何代替 <code>componentWillReceiveProps</code> 的，在“挂载”环节已经讨论过：<code>getDerivedStateFromProps</code> 可以代替 <code>componentWillReceiveProps</code> 实现基于 <code>props 派生 state</code>。</li><li>至于它为何不能完全和 <code>componentWillReceiveProps</code> 画等号，则是因为它过于“专注”了。这一点，单单从<code>getDerivedStateFromProps</code> 这个 API 名字上也能够略窥一二。原则上来说，它能做且只能做这一件事</li></ul><blockquote><p><code>getDerivedStateFromProps</code> 生命周期替代 <code>componentWillReceiveProps</code> 的背后，是 React 16 在强制推行“只用 <code>getDerivedStateFromProps</code> 来完成 <code>props 到 state</code> 的映射”这一最佳实践。确保生命周期函数的行为更加可控可预测，从根源上帮开发者避免不合理的编程方式，避免生命周期的滥用；同时，也是在为新的 Fiber 架构铺路</p></blockquote><p><strong>2. 消失的 componentWillUpdate 与新增的 getSnapshotBeforeUpdate</strong></p><p>咱们先来看看 <code>getSnapshotBeforeUpdate</code> 是什么：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// ...</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这个方法和 <code>getDerivedStateFromProps</code> 颇有几分神似，它们都强调了“我需要一个返回值”这回事。<code>区别在于 getSnapshotBeforeUpdate 的返回值会作为第三个参数给到 componentDidUpdate</code>。它的<code>执行时机是在 render 方法之后，真实 DOM 更新之前</code>。在这个阶段里，我们可以同时获取到更新前的真实 DOM 和更新前后的 <code>state&amp;props</code> 信息</p></blockquote><p>尽管在实际工作中，需要用到这么多信息的场景并不多，但在对于实现一些特殊的需求来说，没它还真的挺难办。这里我举一个非常有代表性的例子：实现一个内容会发生变化的滚动列表，要求根据滚动列表的内容是否发生变化，来决定是否要记录滚动条的当前位置。</p><p>这个需求的前半截要求我们对比更新前后的数据（感知变化），后半截则需要获取真实的 DOM 信息（获取位置），这时用 <code>getSnapshotBeforeUpdate</code> 来解决就再合适不过了。</p><p>对于这个生命周期，<code>需要重点把握的是它与 componentDidUpdate 间的通信过程</code>。在 Demo 中我给出了一个使用示例，它将帮助你更加具体地认知这个过程。代码如下：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token comment">// 组件更新时调用</span></span>
<span class="line">    <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;getSnapshotBeforeUpdate方法执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token string">&quot;haha&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">    <span class="token comment">// 组件更新后调用</span></span>
<span class="line">    <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> valueFromSnapshot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;componentDidUpdate方法执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;从 getSnapshotBeforeUpdate 获取到的值是&quot;</span><span class="token punctuation">,</span> valueFromSnapshot<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们点击 Demo 界面上“修改子组件文本内容”按钮，就可以看到这两个生命周期的通信效果，如下图所示：</p><p><img src="`+m+'" alt=""></p><p>值得一提的是，这个生命周期的设计初衷，是为了“与 <code>componentDidUpdate</code> 一起，涵盖过时的 <code>componentWillUpdate</code> 的所有用例”（引用自 React 官网）。<code>getSnapshotBeforeUpdate</code> 要想发挥作用，离不开 <code>componentDidUpdate</code> 的配合</p><p>那么换个角度想想，为什么 <code>componentWillUpdate</code> 就非死不可呢？说到底，还是因为它“挡了 Fiber 的路”。</p><h2 id="unmounting-阶段-组件的卸载" tabindex="-1"><a class="header-anchor" href="#unmounting-阶段-组件的卸载"><span>Unmounting 阶段：组件的卸载</span></a></h2><p>我们先继续把完整的生命周期流程走完，以下是组件卸载阶段的示意图：</p><p><img src="'+v+'" alt=""></p><p>卸载阶段的生命周期与 <code>React 15</code> 完全一致，只涉及 <code>componentWillUnmount</code> 这一个生命周期，此处不再重复讲解。</p><h2 id="透过现象看本质-react-16-缘何两次求变" tabindex="-1"><a class="header-anchor" href="#透过现象看本质-react-16-缘何两次求变"><span>透过现象看本质：React 16 缘何两次求变</span></a></h2><h3 id="fiber-架构简析" tabindex="-1"><a class="header-anchor" href="#fiber-架构简析"><span>Fiber 架构简析</span></a></h3><p><code>Fiber</code> 是 <code>React 16 对 React 核心算法的一次重写</code>。关于 <code>Fiber</code>，你只需要 <code>get</code> 到这一个点：<code>Fiber 会使原本同步的渲染过程变成异步的</code></p><blockquote><p>在 React 16 之前，每当我们触发一次组件的更新，React 都会构建一棵新的虚拟 DOM 树，通过与上一次的虚拟 DOM 树进行 diff，实现对 DOM 的定向更新。这个过程，是一个递归的过程。下面这张图形象地展示了这个过程的特征</p></blockquote><p><img src="'+g+'" alt=""></p><p>如图所示，<code>同步渲染的递归调用栈是非常深的，只有最底层的调用返回了</code>，整个渲染过程才会开始逐层返回。这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：同步渲染一旦开始，便会牢牢抓住主线程不放，直到递归彻底完成。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。</p><p>而 <code>React 16 引入的 Fiber 架构</code>，恰好能够解决掉这个风险：<code>Fiber</code> 会<code>将一个大的更新任务拆解为许多个小任务</code>。每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”，它的执行过程如下图所示：</p><p><img src="'+b+'" alt=""></p><h3 id="换个角度看生命周期工作流" tabindex="-1"><a class="header-anchor" href="#换个角度看生命周期工作流"><span>换个角度看生命周期工作流</span></a></h3><blockquote><p><code>Fiber 架构的重要特征就是可以被打断的异步渲染模式</code>。但这个“打断”是有原则的，根据“能否被打断”这一标准，React 16 的生命周期被<code>划分为了 render 和 commit 两个阶段</code>，而 <code>commit 阶段又被细分为了 pre-commit 和 commit</code>。每个阶段所涵盖的生命周期如下图所示</p></blockquote><p><img src="'+h+'" alt=""></p><p>我们先来看下三个阶段各自有哪些特征</p><ul><li><code>render 阶段</code>：纯净且没有副作用，可能会被 <code>React 暂停、终止或重新启动</code>。</li><li><code>pre-commit 阶段</code>：可以读取 <code>DOM</code></li><li><code>commit 阶段</code>：可以使用 <code>DOM</code>，运行副作用，安排更新</li></ul><blockquote><p>总的来说，<code>render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的</code></p></blockquote><p>为什么这样设计呢？简单来说，<code>由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知</code>。而 <code>commit 阶段的操作则涉及真实 DOM 的渲染</code>，再狂的框架也不敢在用户眼皮子底下胡乱更改视图，所以这个过程必须用同步渲染来求稳。</p><h3 id="细说生命周期-废旧立新-背后的思考" tabindex="-1"><a class="header-anchor" href="#细说生命周期-废旧立新-背后的思考"><span>细说生命周期“废旧立新”背后的思考</span></a></h3><blockquote><p><code>在 Fiber 机制下，render 阶段是允许暂停、终止和重启的</code>。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。这就导致 render 阶段的生命周期都是有可能被重复执行的</p></blockquote><p><strong>带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期</strong> ：</p><ul><li><code>componentWillMount</code>；</li><li><code>componentWillUpdate</code>；</li><li><code>componentWillReceiveProps</code></li></ul><p>这些生命周期的共性，就是它们都处于 <code>render 阶段</code>，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。</p><blockquote><p>“componentWill”开头的生命周期里，你习惯于做的事情可能包括但不限于:</p></blockquote><ul><li><code>setState()</code>；</li><li><code>fetch</code>发起异步请求；</li><li>操作真实 DOM</li></ul><p>这些操作的问题（或不必要性）包括但不限于以下 3 点</p><ol><li>完全可以转移到其他生命周期（尤其是 <code>componentDidxxx</code>）里去做。</li></ol><p>比如在 <code>componentWillMount</code> 里发起异步请求。很多同学因为太年轻，以为这样做就可以让异步请求回来得“早一点”，从而避免首次渲染白屏。</p><p>可惜你忘了，异步请求再怎么快也快不过（<code>React 15</code> 下）同步的生命周期。<code>componentWillMount</code> 结束后，<code>render</code> 会迅速地被触发，所以说首次渲染依然会在数据返回之前执行。这样做不仅没有达到你预想的目的，还会导致服务端渲染场景下的冗余请求等额外问题，得不偿失。</p><ol start="2"><li>在 Fiber 带来的异步渲染机制下，可能会导致非常严重的 Bug。</li></ol><p>试想，假如你在 <code>componentWillxxx</code> 里发起了一个付款请求。由于 <code>render</code> 阶段里的生命周期都可以重复执行，在 <code>componentWillxxx</code> 被打断 + 重启多次后，就会发出多个付款请求。</p><p>比如说，这件商品单价只要 10 块钱，用户也只点击了一次付款。但实际却可能因为 <code>componentWillxxx</code> 被打断 + 重启多次而多次调用付款接口，最终付了 50 块钱；又或者你可能会习惯在 <code>componentWillReceiveProps</code> 里操作 DOM（比如说删除符合某个特征的元素），那么 <code>componentWillReceiveProps</code> 若是执行了两次，你可能就会一口气删掉两个符合该特征的元素。</p><p>结合上面的分析，我们再去思考 <code>getDerivedStateFromProps</code> 为何会在设计层面直接被约束为一个触碰不到 <code>this</code> 的静态方法，其背后的原因也就更加充分了——避免开发者触碰 this，就是在避免各种危险的骚操作。</p><ol start="3"><li>即使你没有开启异步，<code>React 15</code> 下也有不少人能把自己“玩死”。</li></ol><p>比如在 <code>componentWillReceiveProps</code> 和 <code>componentWillUpdate</code> 里滥用 <code>setState 导致重复渲染死循环的</code>，大家都懂</p><blockquote><p>总的来说，<code>React 16 改造生命周期的主要动机是为了配合 Fiber 架构带来的异步渲染机制</code>。在这个改造的过程中，React 团队精益求精，针对生命周期中长期被滥用的部分推行了具有强制性的最佳实践。这一系列的工作做下来，首先是确保了 Fiber 机制下数据和视图的安全性，同时也确保了生命周期方法的行为更加纯粹、可控、可预测。</p></blockquote><p>阅读全文</p>',104),f=[B];function q(E,w){return a(),s("div",null,f)}const R=n(_,[["render",q],["__file","React-React16为什么要更改生命周期下.html.vue"]]),D=JSON.parse('{"path":"/React-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8B.html","title":"","lang":"zh-CN","frontmatter":{"description":"原文链接: https://interview.poetries.top/principle-docs/react/12-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8B.html 进化的生...","head":[["meta",{"property":"og:url","content":"https://interview.leeguoo.com/React-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8B.html"}],["meta",{"property":"og:site_name","content":"前端面试题集锦"}],["meta",{"property":"og:description","content":"原文链接: https://interview.poetries.top/principle-docs/react/12-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8B.html 进化的生..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://interview.leeguoo.com/images/s_poetries_work_images_20210428184607.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-06T05:59:31.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-06T05:59:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428184607.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428184635.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428172751.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428172830.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428183642.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428183744.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428183909.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428184212.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428185041.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428185206.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428190634.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428191042.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428191428.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428191535.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210428191629.png\\"],\\"dateModified\\":\\"2024-06-06T05:59:31.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"进化的生命周期方法：React 16 生命周期工作流详解","slug":"进化的生命周期方法-react-16-生命周期工作流详解","link":"#进化的生命周期方法-react-16-生命周期工作流详解","children":[]},{"level":2,"title":"Mounting 阶段：组件的初始化渲染（挂载）","slug":"mounting-阶段-组件的初始化渲染-挂载","link":"#mounting-阶段-组件的初始化渲染-挂载","children":[]},{"level":2,"title":"Updating 阶段：组件的更新","slug":"updating-阶段-组件的更新","link":"#updating-阶段-组件的更新","children":[]},{"level":2,"title":"Unmounting 阶段：组件的卸载","slug":"unmounting-阶段-组件的卸载","link":"#unmounting-阶段-组件的卸载","children":[]},{"level":2,"title":"透过现象看本质：React 16 缘何两次求变","slug":"透过现象看本质-react-16-缘何两次求变","link":"#透过现象看本质-react-16-缘何两次求变","children":[{"level":3,"title":"Fiber 架构简析","slug":"fiber-架构简析","link":"#fiber-架构简析","children":[]},{"level":3,"title":"换个角度看生命周期工作流","slug":"换个角度看生命周期工作流","link":"#换个角度看生命周期工作流","children":[]},{"level":3,"title":"细说生命周期“废旧立新”背后的思考","slug":"细说生命周期-废旧立新-背后的思考","link":"#细说生命周期-废旧立新-背后的思考","children":[]}]}],"git":{"updatedTime":1717653571000,"contributors":[{"name":"guoli","email":"guoli@zhihu.com","commits":1}]},"autoDesc":true,"filePathRelative":"React-React16为什么要更改生命周期下.md","excerpt":"<p>原文链接: <a href=\\"https://interview.poetries.top/principle-docs/react/12-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8B.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://interview.poetries.top/principle-docs/react/12-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8B.html</a></p>"}');export{R as comp,D as data};
