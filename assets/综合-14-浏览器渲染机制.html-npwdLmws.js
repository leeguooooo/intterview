import{_ as e,c as o,o as s,a as c}from"./app-f2Cpj3V4.js";const n="/images/s_poetries_work_images_20210504213309.png",a="/images/s_poetries_work_images_20210504213323.png",d="/images/s_poetries_work_images_20210504213334.png",t="/images/s_poetries_work_images_20210504213343.png",p="/images/s_poetries_work_images_20210504213400.png",i="/images/s_poetries_work_images_20210504213408.png",l="/images/s_poetries_work_images_20210504213420.png",r="/images/s_poetries_work_images_20210504213427.png",u={},m=c('<p>原文链接: <a href="https://interview.poetries.top/principle-docs/comprehensive/14-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.html" target="_blank" rel="noopener noreferrer">https://interview.poetries.top/principle-docs/comprehensive/14-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.html</a></p><h2 id="线程和进程" tabindex="-1"><a class="header-anchor" href="#线程和进程"><span>线程和进程</span></a></h2><p>进程和线程的概念可以这样理解：</p><blockquote><p>进程是一个工厂，工厂有它的独立资源--工厂之间相互独立--线程是工厂中的工人，多个工人协作完成任务--工厂内有一个或多个工人--工人之间共享空间</p></blockquote><p>工厂有多个工人，就相当于一个进程可以有多个线程，而且线程共享进程的空间。</p><p><img src="'+n+'" alt=""></p><p>进程是<code>cpu</code>资源分配的最小单位（是能拥有资源和独立运行的最小单位，系统会给它分配内存） 线程是<code>cpu</code>调试的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。核心还是属于一个进程。）</p><h2 id="浏览器是多进程的" tabindex="-1"><a class="header-anchor" href="#浏览器是多进程的"><span>浏览器是多进程的</span></a></h2><p><img src="'+a+'" alt=""></p><p>浏览器是多进程的，每打开一个<code>tab</code>页，就相当于创建了一个独立的浏览器进程。</p><h3 id="浏览器包含的进程" tabindex="-1"><a class="header-anchor" href="#浏览器包含的进程"><span>浏览器包含的进程：</span></a></h3><ol><li><code>Browser</code>进程：浏览器的主进程（负责协调，主控），只有一个，作用有： <ul><li>负责浏览器的界面显示，与用户交互，如前进，后退等</li><li>负责各个页面的管理，创建和销毁其它进程</li><li>将<code>Rendered</code>进程得到的内存中的<code>Bitmap</code>,绘制到用户界面上</li><li>网络资源的管理，下载</li></ul></li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</li><li><code>GPU</code>进程：最多一个，用于<code>3D</code>绘制等。</li><li>浏览器渲染进程（浏览器内核）（<code>Render</code>进程，内部是多线程的）：默认每个<code>Tab</code>页面一个进程，互不影响。主要作用为： <ul><li>页面渲染，脚本执行，事件处理等</li></ul></li></ol><p>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</p><h3 id="浏览器多进程的优势" tabindex="-1"><a class="header-anchor" href="#浏览器多进程的优势"><span>浏览器多进程的优势</span></a></h3><ul><li>避免单个<code>page crash</code>影响整个浏览器</li><li>避免第三方插件<code>crash</code>影响整个浏览器</li><li>多进程充分利用多核优势</li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li></ul><p>简单理解就是：如果浏览器是单进程的，某个<code>Tab</code>页崩溃了，就影响了整个浏览器，体验就会很差。同理如果是单进程的，插件崩溃了也会影响整个浏览器; 当然，内存等资源消耗也会更大，像空间换时间一样。</p><h2 id="重点是浏览器内核-渲染进程" tabindex="-1"><a class="header-anchor" href="#重点是浏览器内核-渲染进程"><span>重点是浏览器内核（渲染进程）</span></a></h2><p>对于普通的前端操作来说，最重要的<strong>渲染进程</strong> ：页面的渲染，<code>js</code>的执行，事件的循环等都在这个进程内执行;</p><p><strong>浏览器是多进程的，浏览器的渲染进程是多线程的；</strong></p><h3 id="gui渲染线程" tabindex="-1"><a class="header-anchor" href="#gui渲染线程"><span><code>GUI</code>渲染线程</span></a></h3><ul><li>负责渲染浏览器界面，解析<code>HTML</code>,<code>CSS</code>,构建<code>DOM</code>树和<code>RenderObject</code>树，布局和绘制等。</li><li>当界面需要重绘或由于某种操作引发回流时，该线程就会执行。</li><li>注意，<strong><code>GUI</code>渲染线程与<code>JS</code>引擎线程是互斥的</strong>，当<code>JS</code>引擎执行时<code>GUI</code>线程会被挂起（相当于冻结了）,<code>GUI</code>更新会被保存在一个队列中等到<code>JS</code>引擎空闲时立即被执行。</li></ul><h3 id="js引擎线程" tabindex="-1"><a class="header-anchor" href="#js引擎线程"><span><code>JS</code>引擎线程</span></a></h3><ul><li>也称为<code>JS</code>内核，负责处理<code>JavaScript</code>脚本程序。（例如<code>V8</code>引擎）。</li><li><code>JS</code>引擎线程负责解析<code>JavaScript</code>脚本，运行代码。</li><li><code>JS</code>引擎一直等待着任务队列中任务的到来，然后加以处理，一个<code>Tab</code>页（<code>render</code>进程）中无论什么时候都只有一个<code>JS</code>线程在运行<code>JS</code>程序。</li><li>同样注意，<code>GUI</code>渲染线程与<code>JS</code>引擎线程是互斥的，所以如果<code>JS</code>执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul><h3 id="事件触发线程" tabindex="-1"><a class="header-anchor" href="#事件触发线程"><span>事件触发线程</span></a></h3><ul><li>归属于浏览器而不是<code>JS</code>引擎，用来控制事件循环（可以理解成<code>JS</code>引擎自己都忙不过来，需要浏览器另开线程协助）。</li><li>当<code>JS</code>引擎执行代码块如<code>setTimeout</code>时（也可来自浏览器内核的其它线程，如鼠标点击，<code>AJAX</code>异步请求等），会将对应任务添加到事件线程中。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待<code>JS</code>引擎的处理。</li><li>注意，由于<code>JS</code>的单线程关系，所以这些待处理队列中的事件都得排队等待<code>JS</code>引擎处理（当<code>JS</code>引擎空闲时才会去执行）。</li></ul><h3 id="定时触发器线程" tabindex="-1"><a class="header-anchor" href="#定时触发器线程"><span>定时触发器线程</span></a></h3><ul><li>传说中的<code>setTimeout</code>和<code>setInterval</code>所在的线程</li><li>浏览器定时计数器并不是由<code>JavaScript</code>引擎计数的，（因为<code>JavaScript</code>引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待<code>JS</code>引擎空闲后执行）</li><li>注意，<code>W3C</code>在<code>HTML</code>标准中规定，规定要求<code>setTimeout</code>中低于<code>4ms</code>的时间间隔算为<code>4ms</code>。</li></ul><h3 id="异步http请求线程" tabindex="-1"><a class="header-anchor" href="#异步http请求线程"><span>异步<code>http</code>请求线程</span></a></h3><ul><li>在<code>XMLHttpRequest</code>在连接后是通过浏览器新型一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由<code>JavaScript</code>引擎执行</li></ul><p>总结下来，渲染进程如下：</p><p><img src="'+d+'" alt=""></p><h3 id="browser主进程和浏览器内核-渲染进程-的通信过程" tabindex="-1"><a class="header-anchor" href="#browser主进程和浏览器内核-渲染进程-的通信过程"><span>Browser主进程和浏览器内核（渲染进程）的通信过程</span></a></h3><p>打开一个浏览器，可以看到：任务管理器出现了2个进程（一个主进程，一个是打开<code>Tab</code>页的渲染进程）；</p><ul><li><code>Browser</code>主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）,随后将该任务通过<code>RendererHost</code>接口传递给<code>Render</code>渲染进程</li><li><code>Render</code>渲染进程的<code>Renderer</code>接口收到消息，简单解释后，交给渲染线程<code>GUI</code>，然后开始渲染</li><li><code>GUI</code>渲染线程接收请求，加载网页并渲染网页，这其中可能需要<code>Browser</code>主进程获取资源和需要<code>GPU</code>进程来帮助渲染</li><li>当然可能会有<code>JS</code>线程操作<code>DOM</code>（这可能会造成回流并重绘）</li><li>最后<code>Render</code>渲染进程将结果传递给<code>Browser</code>主进程</li><li><code>Browser</code>主进程接收到结果并将结果绘制出来</li></ul><p><img src="'+t+'" alt=""></p><h3 id="浏览器内核-渲染进程-中线程之间的关系" tabindex="-1"><a class="header-anchor" href="#浏览器内核-渲染进程-中线程之间的关系"><span>浏览器内核（渲染进程）中线程之间的关系</span></a></h3><p><strong>GUI渲染线程与JS引擎线程互斥</strong></p><p>由于<code>JavaScript</code>是可操作<code>DOM</code>的，如果在修改这些元素属性同时渲染界面（即<code>JS</code>线程和<code>GUI</code>线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p><p>因此，为了防止渲染出现不可预期的结果，浏览器就设置了互斥的关系，当<code>JS</code>引擎执行时<code>GUI</code>线程会被挂起。<code>GUI</code>更新则会被保存在一个队列中等到<code>JS</code>引擎线程空闲时立即被执行。</p><p><strong>JS阻塞页面加载</strong></p><p>从上述的互斥关系，可以推导出，<code>JS</code>如果执行时间过长就会阻塞页面。</p><p>譬如，假设<code>JS</code>引擎正在进行巨量的计算，此时就算<code>GUI</code>有更新，也会被保存在队列中，要等到<code>JS</code>引擎空闲后执行。然后由于巨量计算，所以<code>JS</code>引擎可能很久很久才能空闲，肯定就会感觉很卡。</p><p>所以，要尽量避免<code>JS</code>执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><p><strong><code>css</code>加载是否会阻塞<code>dom</code>树渲染</strong></p><p>这里说的是头部引入<code>css</code>的情况 首先，我们都知道：<code>css</code>是由单独的下载线程异步下载的。 然后还有几个现象：</p><ol><li><code>css</code>加载不会阻塞<code>DOM</code>树解析（异步加载时<code>dom</code>照常构建）</li><li>但会阻塞<code>render</code>树渲染（渲染时需要等<code>css</code>加载完毕，因为<code>render</code>树需要<code>css</code>信息）</li></ol><p>这可能也是浏览器的一种优化机制 因为你加载<code>css</code>的时候，可能会修改下面<code>DOM</code>节点的样式，如果<code>css</code>加载不阻塞<code>render</code>树渲染的话，那么当<code>css</code>加载完之后，<code>render</code>树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗 所以干脆把<code>DOM</code>树的结构先解析完，把可以做的工作做完，然后等<code>css</code>加载完之后，在根据最终的样式来渲染<code>render</code>树，这种做法确实对性能好一点。</p><p><strong><code>WebWorker</code>,<code>JS</code>的多线程？</strong></p><p>前文中有提到<code>JS</code>引擎是单线程的，而且<code>JS</code>执行时间过长会阻塞页面，那么<code>JS</code>就真的对<code>cpu</code>密集型计算无能为力么？</p><p>所以，后来<code>HTML5</code>中支持了<code>WebWorker</code>。</p><p>这样理解下：</p><p>创建<code>Worker</code>时，<code>JS</code>引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作<code>DOM</code>） <code>JS</code>引擎线程与<code>worker</code>线程间通过特定的方式通信（<code>postMessage API</code>，需要通过序列化对象来与线程交互特定的数据）</p><p>所以，如果有非常耗时的工作，请单独开一个<code>Worker</code>线程，这样里面不管如何翻天覆地都不会影响<code>JS</code>引擎主线程，只待计算出结果后，将结果通信给主线程即可，<code>perfect!</code></p><p>而且注意下，<code>JS</code>引擎是单线程的，这一点的本质仍然未改变，<code>Worker</code>可以理解是浏览器给<code>JS</code>引擎开的外挂，专门用来解决那些大量计算问题。</p><p><strong><code>WebWorker</code>与<code>SharedWorker</code></strong></p><p>既然都到了这里，就再提一下<code>SharedWorker</code>（避免后续将这两个概念搞混）</p><p><code>WebWorker</code>只属于某个页面，不会和其他页面的<code>Render</code>进程（浏览器内核进程）共享 所以<code>Chrome</code>在<code>Render</code>进程中（每一个<code>Tab</code>页就是一个<code>render</code>进程）创建一个新的线程来运行<code>Worker</code>中的<code>JavaScript</code>程序。</p><p><code>SharedWorker</code>是浏览器所有页面共享的，不能采用与<code>Worker</code>同样的方式实现，因为它不隶属于某个<code>Render</code>进程，可以为多个<code>Render</code>进程共享使用 所以<code>Chrome</code>浏览器为<code>SharedWorker</code>单独创建一个进程来运行<code>JavaScript</code>程序，在浏览器中每个相同的<code>JavaScript</code>只存在一个<code>SharedWorker</code>进程，不管它被创建多少次。</p><p>看到这里，应该就很容易明白了，本质上就是进程和线程的区别。<code>SharedWorker</code>由独立的进程管理，<code>WebWorker</code>只是属于<code>render</code>进程下的一个线程</p><h3 id="总结浏览器渲染流程" tabindex="-1"><a class="header-anchor" href="#总结浏览器渲染流程"><span>总结浏览器渲染流程</span></a></h3><blockquote><p>浏览器输入<code>url</code>，浏览器主进程接管，开一个下载线程，然后进行<code>http</code>请求（略去<code>DNS</code>查询，<code>IP</code>寻址等等操作），然后等待响应，获取内容，随后将内容通过<code>RendererHost</code>接口转交给<code>Render</code>进程 --浏览器渲染流程开始</p></blockquote><p>浏览器内核拿到内容后，渲染大概可以划分为：</p><ol><li>解析<code>html</code>建立<code>dom</code>要</li><li>解析<code>css</code>构建<code>render</code>树（将<code>css</code>代码解析成树形的数据结构，然后结合<code>dom</code>合并成<code>render</code>树）</li><li>布局<code>render</code>树（<code>Layout/reflow</code>）,负责各元素尺寸，位置的计算</li><li>绘制<code>render</code>树（<code>paint</code>），绘制页面像素信息</li><li>浏览器会将各层的信息发送给<code>GPU</code>，<code>GPU</code>会将各层合成（<code>composite</code>）,显示在屏幕上</li></ol><p>渲染完毕后就是<code>load</code>事件了，之后就是自己的<code>JS</code>逻辑处理了，略去了详细步骤。</p><p><strong><code>load</code>事件与<code>DOMContentLoaded</code>事件的先后</strong></p><p>上面提到，渲染完毕后会触发<code>load</code>事件，那么你能分清楚<code>load</code>事件与<code>DOMContentLoaded</code>事件的先后么？</p><p>很简单，知道它们的定义就可以了：</p><p>当 <code>DOMContentLoaded</code> 事件触发时，仅当<code>DOM</code>加载完成，不包括样式表，图片。 (譬如如果有<code>async</code>加载的脚本就不一定完成)</p><p>当 <code>onload</code> 事件触发时，页面上所有的<code>DOM</code>，样式表，脚本，图片都已经加载完成了。（渲染完毕了）</p><p>所以，顺序是：<code>DOMContentLoaded</code> -&gt; <code>load</code></p><h2 id="普通图层和复合图层" tabindex="-1"><a class="header-anchor" href="#普通图层和复合图层"><span>普通图层和复合图层</span></a></h2><p>渲染步骤就提到了<code>composite</code>概念;浏览器渲染的图层一般包含两大类：普通图层以及复合图层。</p><ol><li>普通文档流内可以理解为一个复合图层（这里默认复合层，里面不管添加多少元素，其实都是在同个复合图层中）</li><li><code>absolute</code>布局（<code>fixed</code>也一样），虽然可以脱离文档流，但它仍然属于默认复合层</li><li>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</li></ol><p>可以简单理解下：<code>GPU</code>中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒</p><p><strong>如何变成复合图层（硬件加速）</strong></p><p>将元素变成一个复合图层，就是传说中的硬件加速技术</p><ul><li>最常用的方式：<code>translate3d</code>,<code>translatez</code></li><li><code>opacity</code>属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</li><li><code>will-chang</code>属性（这个比较偏僻），一般配合<code>opacity</code>与<code>translate</code>使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</li><li><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素</li><li>其它，譬如以前的<code>flash</code>插件</li></ul><p><strong><code>absolute</code>和硬件加速的区别</strong></p><p>可以看到，<code>absolute</code>虽然可以脱离普通文档流，但是无法脱离默认复合层。</p><p>所以，就算<code>absolute</code>中信息改变时不会改变普通文档流中<code>render</code>树，但是，浏览器最终绘制时，是整个复合层绘制的，所以<code>absolute</code>中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，<code>absolute</code>带来的绘制信息变化过大，资源消耗是非常严重的）</p><p>而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</p><p><strong>复合图层的作用</strong></p><p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。 但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。</p><p><strong>硬件加速时请使用<code>index</code></strong></p><p>使用硬件加速时，尽可能的使用index,防止浏览器默认给后续的元素创建复合层渲染 具体的原理是： <code>webkit CSS3</code>中，如果这个元素添加了硬件加速，并且<code>index</code>层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且<code>relective</code>或<code>absolute</code>属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能</p><p>简单点理解，可以认为是一个隐式合成的概念：如果a是一个复合层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意</p><h2 id="从event-loop谈js的运行机制" tabindex="-1"><a class="header-anchor" href="#从event-loop谈js的运行机制"><span>从<code>Event Loop</code>谈<code>JS</code>的运行机制</span></a></h2><p>到此时，已经是属于浏览器页面初次渲染完毕后的事情，<code>JS</code>引擎的一些运行机制分析。主要是结合<code>Event Loop</code>来谈<code>JS</code>代码是如何执行的。 我们已经知道了<code>JS</code>引擎是单线程的，知道了<code>JS</code>引擎线程，事件触发线程，定时触发器线程。 然后还需要知道：</p><ul><li><code>JS</code>分为同步任务和异步任务</li><li>同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件</li><li>一旦执行栈中的所有同步任务执行完毕（此时<code>JS</code>引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈，开始执行。</li></ul><p><img src="'+p+'" alt=""></p><p>看到这里，应该就可以理解了：为什么有时候<code>setTimeOut</code>推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，所以就必须等待，自然有误差。</p><p><img src="'+i+`" alt=""></p><p>主线程在运行时会产生执行栈，栈中的代码调用某些<code>api</code>时，它们会在事件队列中添加各种事件（当满足触发条件后，如<code>ajax</code>请求完毕）。而当栈中的代码执行完毕，就会去读取事件队列中的事件，去执行那些回调，如此循环。</p><h3 id="定时器" tabindex="-1"><a class="header-anchor" href="#定时器"><span>定时器</span></a></h3><p>上面事件循环机制的核心是：<code>JS</code>引擎线程和事件触发线程</p><p>调用<code>setTimeout</code>后，是由定时器线程控制等到特定时间后添加到事件队列的，因为<code>JS</code>引擎是单线程的，如果处于阻塞线程状态就会影响计时准确，因此很有必要另开一个线程用来计时。</p><p>当使用<code>setTimout</code>或<code>setInterval</code>时，需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p><p>如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>&#39;hello<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token comment">//等1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行</span></span>
<span class="line">    </span>
<span class="line">    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;begin&#39;</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行。</p><p>注意：</p><ol><li>执行结果是：先<code>begin</code>，后<code>hello</code></li><li>虽然代码的本意是<code>0</code>毫秒就推入事件队列，但是<code>W3C</code>在<code>HTML</code>标准中规定，规定要求<code>setTimeout</code>中低于<code>4ms</code>的时间间隔算为<code>4ms</code></li><li>就算不等待<code>4ms</code>，就算假设<code>0</code>毫秒就推入事件队列，也会先执行<code>begin</code>（因为只能可执行栈内空了后才会主动读取事件队列）</li></ol><p><strong><code>setInterval</code></strong></p><p>用<code>setTimeout</code>模拟定期计时和直接用<code>setInterval</code>是有区别的：</p><ul><li>每次<code>setTimeout</code>计时到后就会去执行，然后执行一段时间后才会继续<code>setTimeout</code>,中间就多了误差</li><li>而<code>setInterval</code>则是每次都精确的隔一段时间推入一个事件（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）</li></ul><p>而且<code>setInterval</code>有一些比较致命的问题：</p><ul><li>累积效应，如果<code>setInterval</code>代码在<code>setInterval</code>再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔，就算正常间隔执行，多个<code>setInterval</code>的代码执行时间可能会比预期小（因为代码执行需要一定时间）</li><li>比如你<code>ios</code>的<code>webview</code>，或者<code>safari</code>等浏览器中都有一人特点，在滚动的时候是不执行<code>JS</code>的，如果使用了<code>setInterval</code>，会发现在滚动结束后会执行多次由于滚动不执行<code>JS</code>积攒回调，如果回调执行时间过长，就会非常容易造成卡顿问题和一些不可知的错误（<code>setInterval</code>自带的优化，如果当前事件队列中有<code>setInterval</code>的回调，不会重复添加回调）</li><li>而且把浏览器最小化显示等操作时，<code>setInterval</code>并不是不执行程序，它会把<code>setInterval</code>的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行</li></ul><p>所以，至于这么问题，一般认为的最佳方案是：用<code>setTimeout</code>模拟<code>setInterval</code>或者特殊场合直接用<code>requestAnimationFrame</code></p><h3 id="promise时代的microtask与macrotask" tabindex="-1"><a class="header-anchor" href="#promise时代的microtask与macrotask"><span><code>Promise</code>时代的<code>microtask</code>与<code>macrotask</code></span></a></h3><p>在<code>es6</code>盛行的现在，可以看下这题：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;script start&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;setTimeout&#39;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;promise1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;promise2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    </span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;script end&#39;</span><span class="token punctuation">)</span></span>
<span class="line">    </span>
<span class="line">    <span class="token comment">//执行结果：</span></span>
<span class="line">    script start</span>
<span class="line">    script end</span>
<span class="line">    promise1</span>
<span class="line">    promise2</span>
<span class="line">    setTimeout</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为<code>promise</code>有一个新的概念<code>microtask</code>.或者可以说<code>JS</code>中分为两种任务：<code>macrotask</code>和<code>microtask</code>; 理解如下：</p><ul><li><code>macrotask</code>(又叫宏任务),主代码块，<code>setTimeout</code>,<code>setInterval</code>等（可以看到，事件队列中的每一个事件都是一个<code>macrotask</code>）</li><li>可以理解是每次执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</li><li>第一个<code>macrotask</code>会从头到尾将这个任务执行完毕，不会执行其它</li><li>浏览器为了能够使得<code>JS</code>内部<code>macrotask</code>与<code>DOM</code>任务能够有序的执行，会在一个<code>macrotask</code>执行结束后，在下一个<code>macrotask</code>执行开始前，对页面进行重新渲染（<code>task</code>-&gt;渲染-&gt;<code>task</code>-&gt;...）</li><li><code>microtask</code>（又叫微任务），<code>Promise</code>,<code>process.nextTick</code>等。</li><li>可以理解是在当前<code>macrotask</code>执行结束后立即执行的任务</li><li>也就是说在当前<code>macrotask</code>任务后，下一个<code>macrotask</code>之前，在渲染之前</li><li>所以它的响应速度相比<code>setTimeout</code>(<code>setTimeout</code>是<code>macrotask</code>)会更快因为无需等待渲染</li><li>也就是说，在某一个<code>macrotask</code>执行完成后，就会将在它执行期间产生的所有<code>microtask</code>都执行完毕（在渲染前）</li></ul><p>注意：在<code>Node</code>环境下，<code>process.nextTick</code>的优先级高于<code>promise</code>.也就是：在宏任务结束后会先执行微任务队列中的<code>nextTick</code>部分，然后才会执行微任务中的<code>promise</code>部分。</p><p>另外，<code>setImmediate</code>则是规定：在下一次<code>Event Loop</code>（宏任务）时触发（所以它是属于优先级较高的宏任务），（<code>Node.js</code>文档中称，<code>setImmediate</code>指定的回调函数，总是排在<code>setTimeout</code>前面），所以<code>setImmediate</code>如果嵌套的话，是需要经过多个<code>Loop</code>才能完成的，而不会像<code>process.nextTick</code>一样没完没了。</p><p>可以理解：</p><ul><li><code>macrotask</code>中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护.</li><li><code>microtask</code>中的所有微任务都是添加到微任务队列中，等待当前<code>macrotask</code>执行完后执行，而这个队列由<code>JS</code>引擎线程维护。</li></ul><p>所以：</p><ul><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li><li>渲染完毕后，<code>JS</code>线程继续接管，开始下一个宏任务（从事件队列中获取）</li></ul><p><img src="`+l+'" alt=""></p><p><img src="'+r+`" alt=""></p><p><strong><code>new Promise</code>里的函数是直接执行的算做主程序里，而且<code>.then</code>后面的才会放到微任务中。</strong></p><p><strong>另外，请注意下<code>Promise</code>的<code>polyfill</code>与官方版本的区别：</strong></p><p>官方版本中，是标准的<code>microtask</code>形式 <code>polyfill</code>，一般都是通过<code>setTimeout</code>模拟的，所以是<code>macrotask</code>形式 请特别注意这两点区别</p><p>注意，有一些浏览器执行结果不一样（因为它们可能把<code>microtask</code>当成<code>macrotask</code>来执行了），但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）</p><p><code>Mutation Observer</code>可以用来实现<code>microtask</code>（它属于<code>microtask</code>，优先级小于<code>Promise</code>，一般是<code>Promise</code>不支持时才会这样做）</p><p>它是<code>HTML5</code>中的新特性，作用是：监听一个<code>DOM</code>变动，当<code>DOM</code>对象树发生任何变动时，<code>Mutation Observer</code>会得到通知</p><p>像以前的<code>Vue</code>源码中就是利用它来模拟<code>nextTick</code>的，具体原理是，创建一个<code>TextNode</code>并监听内容变化，然后要<code>nextTick</code>的时候去改一下这个节点的文本内容，如下：（<code>Vue</code>的源码，未修改）</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">var</span> counter<span class="token operator">=</span><span class="token number">1</span></span>
<span class="line">    <span class="token keyword">var</span> observer<span class="token operator">=</span><span class="token function">newMutationObserver</span><span class="token punctuation">(</span>nextTickHandler<span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">var</span> textNode<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>textNode<span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">characterData</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token function-variable function">timerFunc</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span></span>
<span class="line">        counter<span class="token operator">=</span><span class="token punctuation">(</span>counter<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span></span>
<span class="line">        textNode<span class="token punctuation">.</span>data<span class="token operator">=</span><span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过，现在的<code>Vue（2.5+）</code>的<code>nextTick</code>实现移除了<code>Mutation Observer</code>的方式（据说是兼容性原因），取而代之的是使用<code>MessageChannel</code>（当然，默认情况仍然是<code>Promise</code>，不支持才兼容的）。</p><p><code>MessageChannel</code>属于宏任务，优先级是：<code>setImmediate-&gt;MessageChannel-&gt;setTimeout</code>，所以<code>Vue（2.5+）</code>内部的<code>nextTick</code>与<code>2.4</code>及之前的实现是不一样的，需要注意下。</p><p>阅读全文</p>`,132),k=[m];function g(h,v){return s(),o("div",null,k)}const b=e(u,[["render",g],["__file","综合-14-浏览器渲染机制.html.vue"]]),S=JSON.parse('{"path":"/%E7%BB%BC%E5%90%88-14-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.html","title":"","lang":"zh-CN","frontmatter":{"description":"原文链接: https://interview.poetries.top/principle-docs/comprehensive/14-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.html 线程和进程 进程和线程的概念可以这样理解： 进程是一个工厂，工厂有它的独立资源...","head":[["meta",{"property":"og:url","content":"https://interview.leeguoo.com/%E7%BB%BC%E5%90%88-14-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"前端面试题集锦"}],["meta",{"property":"og:description","content":"原文链接: https://interview.poetries.top/principle-docs/comprehensive/14-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.html 线程和进程 进程和线程的概念可以这样理解： 进程是一个工厂，工厂有它的独立资源..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://interview.leeguoo.com/images/s_poetries_work_images_20210504213309.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-06T05:59:31.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-06T05:59:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210504213309.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210504213323.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210504213334.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210504213343.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210504213400.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210504213408.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210504213420.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_images_20210504213427.png\\"],\\"dateModified\\":\\"2024-06-06T05:59:31.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"线程和进程","slug":"线程和进程","link":"#线程和进程","children":[]},{"level":2,"title":"浏览器是多进程的","slug":"浏览器是多进程的","link":"#浏览器是多进程的","children":[{"level":3,"title":"浏览器包含的进程：","slug":"浏览器包含的进程","link":"#浏览器包含的进程","children":[]},{"level":3,"title":"浏览器多进程的优势","slug":"浏览器多进程的优势","link":"#浏览器多进程的优势","children":[]}]},{"level":2,"title":"重点是浏览器内核（渲染进程）","slug":"重点是浏览器内核-渲染进程","link":"#重点是浏览器内核-渲染进程","children":[{"level":3,"title":"GUI渲染线程","slug":"gui渲染线程","link":"#gui渲染线程","children":[]},{"level":3,"title":"JS引擎线程","slug":"js引擎线程","link":"#js引擎线程","children":[]},{"level":3,"title":"事件触发线程","slug":"事件触发线程","link":"#事件触发线程","children":[]},{"level":3,"title":"定时触发器线程","slug":"定时触发器线程","link":"#定时触发器线程","children":[]},{"level":3,"title":"异步http请求线程","slug":"异步http请求线程","link":"#异步http请求线程","children":[]},{"level":3,"title":"Browser主进程和浏览器内核（渲染进程）的通信过程","slug":"browser主进程和浏览器内核-渲染进程-的通信过程","link":"#browser主进程和浏览器内核-渲染进程-的通信过程","children":[]},{"level":3,"title":"浏览器内核（渲染进程）中线程之间的关系","slug":"浏览器内核-渲染进程-中线程之间的关系","link":"#浏览器内核-渲染进程-中线程之间的关系","children":[]},{"level":3,"title":"总结浏览器渲染流程","slug":"总结浏览器渲染流程","link":"#总结浏览器渲染流程","children":[]}]},{"level":2,"title":"普通图层和复合图层","slug":"普通图层和复合图层","link":"#普通图层和复合图层","children":[]},{"level":2,"title":"从Event Loop谈JS的运行机制","slug":"从event-loop谈js的运行机制","link":"#从event-loop谈js的运行机制","children":[{"level":3,"title":"定时器","slug":"定时器","link":"#定时器","children":[]},{"level":3,"title":"Promise时代的microtask与macrotask","slug":"promise时代的microtask与macrotask","link":"#promise时代的microtask与macrotask","children":[]}]}],"git":{"updatedTime":1717653571000,"contributors":[{"name":"guoli","email":"guoli@zhihu.com","commits":1}]},"autoDesc":true,"filePathRelative":"综合-14-浏览器渲染机制.md","excerpt":"<p>原文链接: <a href=\\"https://interview.poetries.top/principle-docs/comprehensive/14-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://interview.poetries.top/principle-docs/comprehensive/14-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.html</a></p>"}');export{b as comp,S as data};
