import{_ as n,c as s,o as a,a as e}from"./app-DVMZDNEl.js";const t={},l=e(`<p>原文链接: <a href="https://interview.poetries.top/principle-docs/webpack/05-Babel%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html" target="_blank" rel="noopener noreferrer">https://interview.poetries.top/principle-docs/webpack/05-Babel%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html</a></p><h2 id="babel的包构成" tabindex="-1"><a class="header-anchor" href="#babel的包构成"><span>Babel的包构成</span></a></h2><h3 id="核心包" tabindex="-1"><a class="header-anchor" href="#核心包"><span>核心包</span></a></h3><ul><li>babel-core：babel转译器本身，提供了babel的转译API，如babel.transform等，用于对代码进行转译。像webpack的babel-loader就是调用这些API来完成转译过程的。</li><li>babylon：js的词法解析器</li><li>babel-traverse：用于对AST（抽象语法树，想了解的请自行查询编译原理）的遍历，主要给plugin用</li><li>babel-generator：根据AST生成代码</li></ul><h3 id="功能包" tabindex="-1"><a class="header-anchor" href="#功能包"><span>功能包</span></a></h3><ul><li>babel-types：用于检验、构建和改变AST树的节点</li><li>babel-template：辅助函数，用于从字符串形式的代码来构建AST树节点</li><li>babel-helpers：一系列预制的babel-template函数，用于提供给一些plugins使用</li><li>babel-code-frames：用于生成错误信息，打印出错误点源代码帧以及指出出错位置</li><li><strong>babel-plugin-xxx：babel转译过程中使用到的插件，其中babel-plugin-transform-xxx是transform步骤使用的</strong></li><li><strong>babel-preset-xxx：transform阶段使用到的一系列的plugin</strong></li><li><strong>babel-polyfill：JS标准新增的原生对象和API的shim，实现上仅仅是core-js和regenerator-runtime两个包的封装</strong></li><li><strong>babel-runtime：功能类似babel-polyfill，一般用于library或plugin中，因为它不会污染全局作用域</strong></li></ul><h3 id="工具包" tabindex="-1"><a class="header-anchor" href="#工具包"><span>工具包</span></a></h3><p>babel-cli：babel的命令行工具，通过命令行对js代码进行转译 babel- register：通过绑定node.js的require来自动转译require引用的js代码文件</p><h2 id="babel的配置" tabindex="-1"><a class="header-anchor" href="#babel的配置"><span>babel的配置</span></a></h2><h3 id="使用形式" tabindex="-1"><a class="header-anchor" href="#使用形式"><span>使用形式</span></a></h3><p>如果是以命令行方式使用babel，那么babel的设置就以命令行参数的形式带过去； 还可以在package.json里在babel字段添加设置； 但是建议还是使用一个单独的.babelrc文件，把babel的设置都放置在这里，所有babel API的options（除了回调函数之外）都能够支持，具体的options见<a href="https://link.jianshu.com?t=https://babeljs.io/docs/usage/api/#options" target="_blank" rel="noopener noreferrer">babel的API options文档 (opens new window)</a></p><h3 id="常用options字段说明" tabindex="-1"><a class="header-anchor" href="#常用options字段说明"><span>常用options字段说明</span></a></h3><ul><li>env：指定在不同环境下使用的配置。比如production和development两个环境使用不同的配置，就可以通过这个字段来配置。env字段的从process.env.BABEL_ENV获取，如果BABEL_ENV不存在，则从process.env.NODE_ENV获取，如果NODE_ENV还是不存在，则取默认值&quot;development&quot;</li><li>plugins：要加载和使用的插件列表，插件名前的babel-plugin-可省略；plugin列表按从头到尾的顺序运行</li><li>presets：要加载和使用的preset列表，preset名前的babel-preset-可省略；presets列表的preset按从尾到头的<strong>逆序</strong> 运行（为了兼容用户使用习惯）</li><li>同时设置了presets和plugins，那么plugins的先运行；每个preset和plugin都可以再配置自己的option</li></ul><h3 id="配置文件的查找" tabindex="-1"><a class="header-anchor" href="#配置文件的查找"><span>配置文件的查找</span></a></h3><p>babel会从当前转译的文件所在目录下查找配置文件，如果没有找到，就顺着文档目录树一层层往上查找，一直到.babelrc文件存在或者带babel字段的package.json文件存在为止。</p><h2 id="babel的工作原理" tabindex="-1"><a class="header-anchor" href="#babel的工作原理"><span>babel的工作原理</span></a></h2><p>babel是一个转译器，感觉相对于编译器compiler，叫转译器transpiler更准确，因为它只是把同种语言的高版本规则翻译成低版本规则，而不像编译器那样，输出的是另一种更低级的语言代码。 但是和编译器类似，babel的转译过程也分为三个阶段：<strong>parsing、transforming、generating</strong> ，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：</p><blockquote><p>ES6代码输入 ==》 babylon进行解析 ==》 得到AST ==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树 ==》 用babel-generator通过AST树生成ES5代码</p></blockquote><p>此外，还要注意很重要的一点就是，babel只是转译新标准引入的语法，比如ES6的箭头函数转译成ES5的函数；而<strong>新标准引入的新的原生对象，部分原生对象新增的原型方法，新增的API等（如Proxy、Set等），这些babel是不会转译的。需要用户自行引入polyfill来解决</strong></p><h3 id="plugins" tabindex="-1"><a class="header-anchor" href="#plugins"><span>plugins</span></a></h3><p>插件应用于babel的转译过程，尤其是第二个阶段transforming，如果这个阶段不使用任何插件，那么babel会原样输出代码。 我们主要关注transforming阶段使用的插件，因为transform插件会自动使用对应的词法插件，所以parsing阶段的插件不需要配置。</p><h3 id="presets" tabindex="-1"><a class="header-anchor" href="#presets"><span>presets</span></a></h3><p>如果要自行配置转译过程中使用的各类插件，那太痛苦了，所以babel官方帮我们做了一些预设的插件集，称之为preset，这样我们只需要使用对应的preset就可以了。以JS标准为例，babel提供了如下的一些preset：</p><ul><li>es2015</li><li>es2016</li><li>es2017</li><li>env es20xx的preset只转译该年份批准的标准，而env则代指最新的标准，包括了latest和es20xx各年份 另外，还有 stage-0到stage-4的标准成形之前的各个阶段，这些都是实验版的preset，建议不要使用。</li></ul><h2 id="polyfill" tabindex="-1"><a class="header-anchor" href="#polyfill"><span>polyfill</span></a></h2><p>polyfill是一个针对ES2015+环境的shim，实现上来说babel-polyfill包只是简单的把core-js和regenerator runtime包装了下，这两个包才是真正的实现代码所在（后文会详细介绍core-js）。 使用babel- polyfill会把ES2015+环境整体引入到你的代码环境中，让你的代码可以直接使用新标准所引入的新原生对象，新API等，一般来说单独的应用和页面都可以这样使用。</p><h3 id="使用方法" tabindex="-1"><a class="header-anchor" href="#使用方法"><span>使用方法</span></a></h3><ol><li>先安装包： npm install --save babel-polyfill</li><li>要确保<strong>在入口处导入polyfill</strong> ，因为polyfill代码需要在所有其他代码前先被调用 代码方式： <code>import &quot;babel-polyfill&quot;</code> webpack配置： <code>module.exports = { entry: [&quot;babel-polyfill&quot;, &quot;./app/js&quot;] };</code></li></ol><p>如果只是需要引入部分新原生对象或API，那么可以按需引入，而不必导入全部的环境，具体见下文的core-js</p><h2 id="runtime" tabindex="-1"><a class="header-anchor" href="#runtime"><span>runtime</span></a></h2><h3 id="polyfill和runtime的区别" tabindex="-1"><a class="header-anchor" href="#polyfill和runtime的区别"><span>polyfill和runtime的区别</span></a></h3><p>直接使用babel- polyfill对于应用或页面等环境在你控制之中的情况来说，并没有什么问题。但是对于在library中使用polyfill，就变得不可行了。因为library是供外部使用的，但外部的环境并不在library的可控范围，而polyfill是会污染原来的全局环境的（因为新的原生对象、API这些都直接由polyfill引入到全局环境）。这样就很容易会发生冲突，所以这个时候，babel- runtime就可以派上用场了。</p><h3 id="transform-runtime和babel-runtime" tabindex="-1"><a class="header-anchor" href="#transform-runtime和babel-runtime"><span>transform-runtime和babel-runtime</span></a></h3><p>babel-plugin-transform-runtime插件依赖babel-runtime，babel- runtime是真正提供runtime环境的包；也就是说transform- runtime插件是把js代码中使用到的新原生对象和静态方法转换成对runtime实现包的引用，举个例子如下：</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line">    <span class="token comment">// 输入的ES6代码</span></span>
<span class="line">    <span class="token keyword">var</span> sym <span class="token operator">=</span> <span class="token class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 通过transform-runtime转换后的ES5+runtime代码 </span></span>
<span class="line">    <span class="token keyword">var</span> _symbol <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;babel-runtime/core-js/symbol&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">var</span> sym <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> _symbol<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面这个例子可见，原本代码中使用的ES6新原生对象Symbol被transform-runtimec插件转换成了babel- runtime的实现，既保持了Symbol的功能，同时又没有像polyfill那样污染全局环境（因为最终生成的代码中，并没有对Symbol的引用） 另外，这里我们也可以隐约发现，babel-runtime其实也不是真正的实现代码所在，真正的代码实现是在core-js中，后面我们再说</p><h3 id="transform-runtime插件的功能" tabindex="-1"><a class="header-anchor" href="#transform-runtime插件的功能"><span>transform-runtime插件的功能</span></a></h3><ol><li>把代码中的使用到的ES6引入的新原生对象和静态方法用babel-runtime/core-js导出的对象和方法替代</li><li>当使用generators或async函数时，用babel-runtime/regenerator导出的函数取代（类似polyfill分成regenerator和core-js两个部分）</li><li>把Babel生成的辅助函数改为用babel-runtime/helpers导出的函数来替代（babel默认会在每个文件顶部放置所需要的辅助函数，如果文件多的话，这些辅助函数就在每个文件中都重复了，通过引用babel-runtime/helpers就可以统一起来，减少代码体积）</li></ol><blockquote><ul><li>上述三点就是transform-runtime插件所做的事情，由此也可见，babel- runtime就是一个提供了regenerator、core-js和helpers的运行时库。</li><li>建议不要直接使用babel-runtime，因为transform-runtime依赖babel- runtime，大部分情况下都可以用transform-runtime达成目的。</li><li>此外，transform- runtime在.babelrc里配置的时候，还可以设置helpers、polyfill、regenerator这三个开关，以自行决定runtime是否要引入对应的功能。</li><li>最后补充一点：由于runtime不会污染全局空间，所以<strong>实例方法是无法工作的</strong> （因为这必须在原型链上添加这个方法，这是和polyfill最大的不同） ，比如：</li></ul></blockquote><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx" data-title="jsx"><pre><code><span class="line">    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    arr<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 实例方法不行</span></span>
<span class="line">    <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 用原型链来调用也是不行</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="通过core-js实现按需引入polyfill或runtime" tabindex="-1"><a class="header-anchor" href="#通过core-js实现按需引入polyfill或runtime"><span>通过core-js实现按需引入polyfill或runtime</span></a></h2><p>core-js包才上述的polyfill、runtime的核心，因为polyfill和runtime其实都只是对core- js和regenerator的再封装，方便使用而已。</p><blockquote><p>但是polyfill和runtime都是整体引入的，不能做细粒度的调整，如果我们的代码只是用到了小部分ES6而导致需要使用polyfill和runtime的话，会造成代码体积不必要的增大（runtime的影响较小）。所以，按需引入的需求就自然而然产生了，这个时候就得依靠core- js来实现了。</p></blockquote><h3 id="core-js的组织结构" tabindex="-1"><a class="header-anchor" href="#core-js的组织结构"><span>core-js的组织结构</span></a></h3><p>首先，core-js有三种使用方式：</p><ul><li>默认方式：require(&#39;core-js&#39;) 这种方式包括全部特性，标准的和非标准的</li><li>库的形式： var core = require(&#39;core-js/library&#39;) 这种方式也包括全部特性，只是它不会污染全局名字空间</li><li>只是shim： require(&#39;core-js/shim&#39;)或var shim = require(&#39;core-js/library/shim&#39;) 这种方式只包括标准特性（就是只有polyfill功能，没有扩展的特性）</li></ul><p>core-js的结构是高度模块化的，它把每个特性都组织到一个小模块里，然后再把这些小模块组合成一个大特性，层层组织。比如：</p><blockquote><p>core-js/es6（core-js/library/es6）就包含了全部的ES6特性，而core-js/es6/array（core- js/library/es6/array）则只包含ES6的Array特性，而core-js/fn/array/from（core- js/library/fn/array/from）则只有Array.from这个实现。 实现按需使用，就是自己选择使用到的特性，然后导入即可。具体的每个特性和对应的路径可以直接查看[core-js的github (opens new window)](https://link.jianshu.com?t=https://github.com/zloirock/core- js#ecmascript-6)</p></blockquote><h3 id="core-js的按需使用" tabindex="-1"><a class="header-anchor" href="#core-js的按需使用"><span>core-js的按需使用</span></a></h3><p>1、类似polyfill，直接把特性添加到全局环境，这种方式体验最完整</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx" data-title="jsx"><pre><code><span class="line">    <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;core-js/fn/set&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;core-js/fn/array/from&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;core-js/fn/array/find-index&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// =&gt; [1, 2, 3]</span></span>
<span class="line">    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span>isNaN<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// =&gt; 2</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、类似runtime一样，以库的形式来使用特性，这种方式不会污染全局名字空间，但是不能使用实例方法</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx" data-title="jsx"><pre><code><span class="line">    <span class="token keyword">var</span> Set       <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;core-js/library/fn/set&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">var</span> from      <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;core-js/library/fn/array/from&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">var</span> findIndex <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;core-js/library/fn/array/find-index&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// =&gt; [1, 2, 3]</span></span>
<span class="line">    <span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> isNaN<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// =&gt; 2</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、因为第二种库的形式不能使用prototype方法，所以第三种方式使用了一个小技巧，通过::这个符号而不是.来调用实例方式，从而达到曲线救国的目的。这种方式的使用，路径中都会带有/virtual/</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx" data-title="jsx"><pre><code><span class="line">    <span class="token keyword">import</span> <span class="token punctuation">{</span>fill<span class="token punctuation">,</span> findIndex<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;core-js/library/fn/array/virtual&#39;</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token operator">:</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> b <span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token operator">:</span><span class="token operator">:</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">it</span> <span class="token operator">=&gt;</span> it <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>it <span class="token operator">%</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// =&gt; 4</span></span>
<span class="line">    </span>
<span class="line">    <span class="token comment">// 对比下polyfill的实现 </span></span>
<span class="line">    <span class="token comment">// Array(10).fill(0).map((a, b) =&gt; b * b).findIndex(it =&gt; it &amp;&amp; !(it % 8));</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>Babel使用的难点主要在于理解polyfill、runtime和core-js，通过本文，把这三者的概念和关系理清楚了，对babel的使用就不存在问题！</p><p>阅读全文</p>`,58),p=[l];function o(i,r){return a(),s("div",null,p)}const u=n(t,[["render",o],["__file","Webpack-05-Babel原理及其使用.html.vue"]]),b=JSON.parse('{"path":"/Webpack-05-Babel%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html","title":"","lang":"zh-CN","frontmatter":{"description":"原文链接: https://interview.poetries.top/principle-docs/webpack/05-Babel%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html Babel的包构成 核心包 babel-core：babel转译器本身，提供了babel的转译AP...","head":[["meta",{"property":"og:url","content":"https://interview.leeguoo.com/Webpack-05-Babel%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html"}],["meta",{"property":"og:site_name","content":"前端面试题集锦"}],["meta",{"property":"og:description","content":"原文链接: https://interview.poetries.top/principle-docs/webpack/05-Babel%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html Babel的包构成 核心包 babel-core：babel转译器本身，提供了babel的转译AP..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-06T05:59:31.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-06T05:59:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-06T05:59:31.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Babel的包构成","slug":"babel的包构成","link":"#babel的包构成","children":[{"level":3,"title":"核心包","slug":"核心包","link":"#核心包","children":[]},{"level":3,"title":"功能包","slug":"功能包","link":"#功能包","children":[]},{"level":3,"title":"工具包","slug":"工具包","link":"#工具包","children":[]}]},{"level":2,"title":"babel的配置","slug":"babel的配置","link":"#babel的配置","children":[{"level":3,"title":"使用形式","slug":"使用形式","link":"#使用形式","children":[]},{"level":3,"title":"常用options字段说明","slug":"常用options字段说明","link":"#常用options字段说明","children":[]},{"level":3,"title":"配置文件的查找","slug":"配置文件的查找","link":"#配置文件的查找","children":[]}]},{"level":2,"title":"babel的工作原理","slug":"babel的工作原理","link":"#babel的工作原理","children":[{"level":3,"title":"plugins","slug":"plugins","link":"#plugins","children":[]},{"level":3,"title":"presets","slug":"presets","link":"#presets","children":[]}]},{"level":2,"title":"polyfill","slug":"polyfill","link":"#polyfill","children":[{"level":3,"title":"使用方法","slug":"使用方法","link":"#使用方法","children":[]}]},{"level":2,"title":"runtime","slug":"runtime","link":"#runtime","children":[{"level":3,"title":"polyfill和runtime的区别","slug":"polyfill和runtime的区别","link":"#polyfill和runtime的区别","children":[]},{"level":3,"title":"transform-runtime和babel-runtime","slug":"transform-runtime和babel-runtime","link":"#transform-runtime和babel-runtime","children":[]},{"level":3,"title":"transform-runtime插件的功能","slug":"transform-runtime插件的功能","link":"#transform-runtime插件的功能","children":[]}]},{"level":2,"title":"通过core-js实现按需引入polyfill或runtime","slug":"通过core-js实现按需引入polyfill或runtime","link":"#通过core-js实现按需引入polyfill或runtime","children":[{"level":3,"title":"core-js的组织结构","slug":"core-js的组织结构","link":"#core-js的组织结构","children":[]},{"level":3,"title":"core-js的按需使用","slug":"core-js的按需使用","link":"#core-js的按需使用","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1717653571000,"contributors":[{"name":"guoli","email":"guoli@zhihu.com","commits":1}]},"autoDesc":true,"filePathRelative":"Webpack-05-Babel原理及其使用.md","excerpt":"<p>原文链接: <a href=\\"https://interview.poetries.top/principle-docs/webpack/05-Babel%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://interview.poetries.top/principle-docs/webpack/05-Babel%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html</a></p>"}');export{u as comp,b as data};
