import{_ as e,a,b as s}from"./s_poetries_work_gitee_2019_12_17-BOJ5mqQK.js";import{_ as t,c as n,o,a as c}from"./app-TapK6V6W.js";const p={},i=c('<p>原文链接: <a href="https://interview.poetries.top/fe-base-docs/http-protocol/base/12-HTTP%E7%9A%84%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE.html" target="_blank" rel="noopener noreferrer">https://interview.poetries.top/fe-base-docs/http-protocol/base/12-HTTP%E7%9A%84%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE.html</a></p><h2 id="数据类型与编码" tabindex="-1"><a class="header-anchor" href="#数据类型与编码"><span>数据类型与编码</span></a></h2><ul><li>text：即文本格式的可读数据，我们最熟悉的应该就是 <code>text/html</code> 了，表示超文本文档，此外还有纯文本 <code>text/plain</code>、样式表 <code>text/css</code> 等。</li><li><code>image</code>：即图像文件，有 <code>image/gif</code>、<code>image/jpeg</code>、<code>image/png</code> 等。</li><li><code>audio/video</code>：音频和视频数据，例如 <code>audio/mpeg</code>、<code>video/mp4</code> 等。</li><li><code>application</code>：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 <code>application/json</code>，<code>application/javascript</code>、<code>application/pdf</code> 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 <code>application/octet-stream</code>，即不透明的二进制数据</li></ul><blockquote><p>但仅有 <code>MIME type</code> 还不够，因为 <code>HTTP</code> 在传输时为了节约带宽，有时候还会压缩数据，为了不要让浏览器继续“猜”，还需要有一个“Encoding type”，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。</p></blockquote><p><strong>比起<code>MIME type</code> 来说，<code>Encoding type</code> 就少了很多，常用的只有下面三种</strong></p><ul><li><code>gzip</code>：<code>GNU zip</code> 压缩格式，也是互联网上最流行的压缩格式；</li><li><code>deflate</code>：<code>zlib</code>（<code>deflate</code>）压缩格式，流行程度仅次于 <code>gzip</code>；</li><li><code>br</code>：一种专门为 <code>HTTP</code> 优化的新压缩算法（<code>Brotli</code>）</li></ul><h2 id="数据类型使用的头字段" tabindex="-1"><a class="header-anchor" href="#数据类型使用的头字段"><span>数据类型使用的头字段</span></a></h2><p>有了 <code>MIME type</code> 和 <code>Encoding type</code>，无论是浏览器还是服务器就都可以轻松识别出 <code>body</code> 的类型，也就能够正确处理数据了。</p><p><code>HTTP</code> 协议为此定义了两个 <code>Accept</code> 请求头字段和两个 <code>Content</code> 实体头字段，用于客户端和服务器进行“内容协商”。也就是说，客户端用 <code>Accept</code> 头告诉服务器希望接收什么样的数据，而服务器用 <code>Content</code> 头告诉客户端实际发送了什么样的数据</p><p><img src="'+e+`" alt=""></p><blockquote><p><code>Accept</code>字段标记的是客户端可理解的 <code>MIME</code> type，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：</p></blockquote><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token literal-property property">Accept</span><span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">,</span>application<span class="token operator">/</span>xml<span class="token punctuation">,</span>image<span class="token operator">/</span>webp<span class="token punctuation">,</span>image<span class="token operator">/</span>png</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这就是告诉服务器：“我能够看懂 HTML、XML 的文本，还有 <code>webp</code> 和 <code>png</code> 的图片，请给我这四类格式的数据”。</p><p>相应的，服务器会在响应报文里用头字段<code>Content-Type</code>告诉实体数据的真实类型：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>html</span>
<span class="line">    Content<span class="token operator">-</span>Type<span class="token operator">:</span> image<span class="token operator">/</span>png</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样浏览器看到报文里的类型是“text/html”就知道是 HTML 文件，会调用排版引擎渲染出页面，看到“image/png”就知道是一个 PNG 文件，就会在页面上显示出图像。</p><p>Accept-Encoding字段标记的是客户端支持的压缩格式，例如上面说的 gzip、deflate 等，同样也可以用“,”列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应头字段<code>Content-Encoding</code>里</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    Accept<span class="token operator">-</span>Encoding<span class="token operator">:</span> gzip<span class="token punctuation">,</span> deflate<span class="token punctuation">,</span> br</span>
<span class="line">    Content<span class="token operator">-</span>Encoding<span class="token operator">:</span> gzip</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>不过这两个字段是可以省略的，如果请求报文里没有 <code>Accept-Encoding</code> 字段，就表示客户端不支持压缩数据；如果响应报文里没有 <code>Content- Encoding</code> 字段，就表示响应数据没有被压缩</p><h2 id="语言类型使用的头字段" tabindex="-1"><a class="header-anchor" href="#语言类型使用的头字段"><span>语言类型使用的头字段</span></a></h2><p>同样的，HTTP 协议也使用 <code>Accept</code> 请求头字段和 <code>Content</code> 实体头字段，用于客户端和服务器就语言与编码进行“内容协商”。</p><p><code>Accept-Language</code>字段标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型，例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    Accept<span class="token operator">-</span>Language<span class="token operator">:</span> zh<span class="token operator">-</span><span class="token constant">CN</span><span class="token punctuation">,</span> zh<span class="token punctuation">,</span> en</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个请求头会告诉服务器：“最好给我 <code>zh-CN</code> 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文”。</p><p>相应的，服务器应该在响应报文里用头字段<code>Content-Language</code>告诉客户端实体数据使用的实际语言类型</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    Content<span class="token operator">-</span>Language<span class="token operator">:</span> zh<span class="token operator">-</span><span class="token constant">CN</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>字符集在 <code>HTTP</code> 里使用的请求头字段是<code>Accept-Charset</code>，但响应头里却没有对应的 <code>Content-Charset</code>，而是在<code>Content-Type</code>字段的数据类型后面用“<code>charset=xxx</code>”来表示，这点需要特别注意。</li><li>例如，浏览器请求 <code>GBK</code> 或 <code>UTF-8</code> 的字符集，然后服务器返回的是 <code>UTF-8</code> 编码，就是下面这样</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    Accept<span class="token operator">-</span>Charset<span class="token operator">:</span> gbk<span class="token punctuation">,</span> utf<span class="token operator">-</span><span class="token number">8</span></span>
<span class="line">    Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>不过现在的浏览器都支持多种字符集，通常不会发送 <code>Accept-Charset</code>，而服务器也不会发送 <code>Content- Language</code>，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 <code>Accept-Language</code> 字段，响应头里只会有 <code>Content-Type</code>字段</p><p><img src="`+a+`" alt=""></p><h2 id="内容协商的质量值" tabindex="-1"><a class="header-anchor" href="#内容协商的质量值"><span>内容协商的质量值</span></a></h2><p>在 HTTP 协议里用 <code>Accept</code>、<code>Accept-Encoding</code>、<code>Accept-Language</code> 等请求头字段进行内容协商的时候，还可以用一种特殊的“q”参数表示权重来设定优先级，这里的“q”是“quality factor”的意思。</p><p>权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。</p><p>这里要提醒的是“;”的用法，在大多数编程语言里“;”的断句语气要强于“,”，而在 HTTP 的内容协商里却恰好反了过来，“;”的意义是小于“,”的。</p><p>例如下面的 Accept 字段：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token literal-property property">Accept</span><span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">,</span>application<span class="token operator">/</span>xml<span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token comment">/*;q=0.8</span>
<span class="line"></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML</p><h2 id="内容协商的结果" tabindex="-1"><a class="header-anchor" href="#内容协商的结果"><span>内容协商的结果</span></a></h2><p>内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个Vary字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token literal-property property">Vary</span><span class="token operator">:</span> Accept<span class="token operator">-</span>Encoding<span class="token punctuation">,</span>User<span class="token operator">-</span>Agent<span class="token punctuation">,</span>Accept</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个 <code>Vary</code> 字段表示服务器依据了 <code>Accept-Encoding</code>、<code>User-Agent</code> 和 <code>Accept</code> 这三个头字段，然后决定了发回的响应报文。</p><p><code>Vary</code> 字段可以认为是响应报文的一个特殊的“版本标记”。每当 <code>Accept</code> 等请求头变化时，<code>Vary</code> 也会随着响应报文一起变化。也就是说，同一个 <code>URI</code> 可能会有多个不同的“版本”，主要用在传输链路中间的代理服务器实现缓存服务，这个之后讲“HTTP 缓存”时还会再提到</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p><img src="`+s+'" alt=""></p><ul><li>数据类型表示实体数据的内容是什么，使用的是 <code>MIME type</code>，相关的头字段是 <code>Accept</code>和 <code>Content-Type</code>；</li><li>数据编码表示实体数据的压缩方式，相关的头字段是 <code>Accept-Encoding</code> 和 <code>Content-Encoding</code>；</li><li>语言类型表示实体数据的自然语言，相关的头字段是 <code>Accept-Language</code> 和 <code>Content-Language</code>；</li><li>字符集表示实体数据的编码方式，相关的头字段是 <code>Accept-Charset</code>和 Content-Type；</li><li>客户端需要在请求头里使用 <code>Accept</code> 等头字段与服务器进行“内容协商”，要求服务器返回最合适的数据； <code>Accept</code> 等头字段可以用“,”顺序列出多个可能的选项，还可以用“<code>;q=</code>”参数来精确指定权重</li></ul><p>阅读全文</p>',46),l=[i];function d(r,u){return o(),n("div",null,l)}const m=t(p,[["render",d],["__file","http 基础-12-HTTP的实体数据.html.vue"]]),v=JSON.parse('{"path":"/http%20%E5%9F%BA%E7%A1%80-12-HTTP%E7%9A%84%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE.html","title":"","lang":"zh-CN","frontmatter":{"description":"原文链接: https://interview.poetries.top/fe-base-docs/http-protocol/base/12-HTTP%E7%9A%84%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE.html 数据类型与编码 text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超...","head":[["meta",{"property":"og:url","content":"https://interview.leeguoo.com/http%20%E5%9F%BA%E7%A1%80-12-HTTP%E7%9A%84%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE.html"}],["meta",{"property":"og:site_name","content":"前端面试题集锦"}],["meta",{"property":"og:description","content":"原文链接: https://interview.poetries.top/fe-base-docs/http-protocol/base/12-HTTP%E7%9A%84%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE.html 数据类型与编码 text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_12_15.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-06T05:59:31.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-06T05:59:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_12_15.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_12_16.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_12_17.png\\"],\\"dateModified\\":\\"2024-06-06T05:59:31.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"数据类型与编码","slug":"数据类型与编码","link":"#数据类型与编码","children":[]},{"level":2,"title":"数据类型使用的头字段","slug":"数据类型使用的头字段","link":"#数据类型使用的头字段","children":[]},{"level":2,"title":"语言类型使用的头字段","slug":"语言类型使用的头字段","link":"#语言类型使用的头字段","children":[]},{"level":2,"title":"内容协商的质量值","slug":"内容协商的质量值","link":"#内容协商的质量值","children":[]},{"level":2,"title":"内容协商的结果","slug":"内容协商的结果","link":"#内容协商的结果","children":[]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"updatedTime":1717653571000,"contributors":[{"name":"guoli","email":"guoli@zhihu.com","commits":1}]},"autoDesc":true,"filePathRelative":"http 基础-12-HTTP的实体数据.md","excerpt":"<p>原文链接: <a href=\\"https://interview.poetries.top/fe-base-docs/http-protocol/base/12-HTTP%E7%9A%84%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://interview.poetries.top/fe-base-docs/http-protocol/base/12-HTTP%E7%9A%84%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE.html</a></p>"}');export{m as comp,v as data};
