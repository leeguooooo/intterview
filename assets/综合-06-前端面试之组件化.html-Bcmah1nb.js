import{_ as e,c as t,o as i,a as o}from"./app-f2Cpj3V4.js";const s="/images/s_poetries_work_gitee_2019_10_56.png",l="/images/s_poetries_work_gitee_2019_10_57.png",c="/images/s_poetries_work_gitee_2019_10_58.png",a="/images/s_poetries_work_gitee_2019_10_59.png",r="/images/s_poetries_work_gitee_2019_10_60.png",_="/images/s_poetries_work_gitee_2019_10_61.png",n="/images/s_poetries_work_gitee_2019_10_62.png",p="/images/s_poetries_work_gitee_2019_10_63.png",d="/images/s_poetries_work_gitee_2019_10_64.png",g="/images/s_poetries_work_gitee_2019_10_65.png",h="/images/s_poetries_work_gitee_2019_10_66.png",m="/images/s_poetries_work_gitee_2019_10_67.png",u="/images/s_poetries_work_gitee_2019_10_68.png",v="/images/s_poetries_work_gitee_2019_10_69.png",B="/images/s_poetries_work_gitee_2019_10_70.png",E="/images/s_poetries_work_gitee_2019_10_71.png",k={},w=o('<p>原文链接: <a href="https://interview.poetries.top/principle-docs/comprehensive/06-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96.html" target="_blank" rel="noopener noreferrer">https://interview.poetries.top/principle-docs/comprehensive/06-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96.html</a></p><p><img src="'+s+'" alt="img"></p><h2 id="一、说一下对组件化的理解" tabindex="-1"><a class="header-anchor" href="#一、说一下对组件化的理解"><span>一、说一下对组件化的理解</span></a></h2><h3 id="_1-1-组件的封装" tabindex="-1"><a class="header-anchor" href="#_1-1-组件的封装"><span>1.1 组件的封装</span></a></h3><ul><li>视图</li><li>数据</li><li>变化逻辑</li></ul><p><img src="'+l+'" alt="img"></p><h3 id="_1-2-组件的复用" tabindex="-1"><a class="header-anchor" href="#_1-2-组件的复用"><span>1.2 组件的复用</span></a></h3><ul><li><code>props</code> 传递</li><li>复用</li></ul><p><img src="'+c+'" alt="img"></p><p><img src="'+a+'" alt="img"></p><h2 id="二、jsx-本质是什么" tabindex="-1"><a class="header-anchor" href="#二、jsx-本质是什么"><span>二、JSX 本质是什么</span></a></h2><h3 id="_2-1-jsx-语法" tabindex="-1"><a class="header-anchor" href="#_2-1-jsx-语法"><span>2.1 JSX 语法</span></a></h3><ul><li><code>html</code> 形式</li><li>引入 <code>JS</code> 变量和表达式</li><li>循环</li><li><code>style</code> 和 <code>className</code></li><li>事件</li></ul><blockquote><ul><li>JSX 语法根本无法被浏览器所解析</li><li>那么它如何在浏览器运行？</li></ul></blockquote><p><img src="'+r+'" alt="img"></p><h3 id="_2-2-jsx-解析" tabindex="-1"><a class="header-anchor" href="#_2-2-jsx-解析"><span>2.2 JSX 解析</span></a></h3><ul><li><code>JSX</code> 其实是语法糖</li><li>开发环境会将 <code>JSX</code> 编译成 <code>JS</code> 代码</li><li><code>JSX</code> 的写法大大降低了学习成本和编码工作量</li><li>同时，<code>JSX</code> 也会增加 <code>debug</code>成本</li></ul><p><img src="'+_+'" alt="img"></p><p><img src="'+n+'" alt="img"></p><p><img src="'+p+'" alt="img"></p><h3 id="_2-3-jsx-独立的标准" tabindex="-1"><a class="header-anchor" href="#_2-3-jsx-独立的标准"><span>2.3 JSX 独立的标准</span></a></h3><ul><li><code>JSX</code> 是 <code>React</code> 引入的，但不是 <code>React</code> 独有的</li><li><code>React</code>已经将它作为一个独立标准开放，其他项目也可用</li><li><code>React.createElement</code> 是可以自定义修改的</li><li>说明：本身功能已经完备；和其他标准监控和扩展性没问题</li></ul><h2 id="三、jsx-和-vdom-的关系" tabindex="-1"><a class="header-anchor" href="#三、jsx-和-vdom-的关系"><span>三、JSX 和 vdom 的关系</span></a></h2><h3 id="_3-1-为何需要-vdom" tabindex="-1"><a class="header-anchor" href="#_3-1-为何需要-vdom"><span>3.1 为何需要 vdom</span></a></h3><ul><li><code>vdom</code> 是 <code>React</code>初次推广开来的，结合 <code>JSX</code></li><li><code>JSX</code> 就是模板，最终要渲染成 <code>html</code></li><li>初次渲染 + 修改 <code>state</code> 后的 <code>re-render</code></li><li>正好符合 <code>vdom</code> 的应用场景</li></ul><h3 id="_3-2-react-createelement-和-h" tabindex="-1"><a class="header-anchor" href="#_3-2-react-createelement-和-h"><span>3.2 React.createElement 和 h</span></a></h3><p><img src="'+d+'" alt="img"></p><h3 id="_3-3-何时-patch" tabindex="-1"><a class="header-anchor" href="#_3-3-何时-patch"><span>3.3 何时 patch</span></a></h3><ul><li>初次渲染 - <code>ReactDOM.render(&lt;App/&gt;, container)</code></li><li>会触发 <code>patch(container, vnode)</code></li><li><code>re-render</code> - <code>setState</code></li><li>会触发 <code>patch(vnode, newVnode)</code></li></ul><h3 id="_3-4-自定义组件的解析" tabindex="-1"><a class="header-anchor" href="#_3-4-自定义组件的解析"><span>3.4 自定义组件的解析</span></a></h3><p><img src="'+g+'" alt="img"></p><ul><li><code>‘div’</code> - 直接渲染 <code>&lt;div&gt;</code> 即可，<code>vdom</code> 可以做到</li><li><code>Input</code> 和 <code>List</code> ，是自定义组件（<code>class</code>），<code>vdom</code> 默认不认识</li><li>因此 <code>Input</code> 和 <code>List</code> 定义的时候必须声明 <code>render</code> 函数</li><li>根据 <code>props</code> 初始化实例，然后执行实例的 <code>render</code> 函数</li><li><code>render</code> 函数返回的还是 <code>vnode</code>对象</li></ul><p><img src="'+h+'" alt="img"></p><h2 id="四、说一下-react-setstate-的过程" tabindex="-1"><a class="header-anchor" href="#四、说一下-react-setstate-的过程"><span>四、说一下 React setState 的过程</span></a></h2><h3 id="_4-1-setstate-的异步" tabindex="-1"><a class="header-anchor" href="#_4-1-setstate-的异步"><span>4.1 setState 的异步</span></a></h3><p><img src="'+m+'" alt="img"></p><p><strong>setState 为何需要异步？</strong></p><ul><li>可能会一次执行多次 <code>setState</code></li><li>你无法规定、限制用户如何使用 <code>setState</code></li><li>没必要每次 <code>setState</code> 都重新渲染，考虑性能</li><li>即便是每次重新渲染，用户也看不到中间的效果</li><li>只看到最后的结果即可</li></ul><p><img src="'+u+'" alt="img"></p><h3 id="_4-2-vue-修改属性也是异步" tabindex="-1"><a class="header-anchor" href="#_4-2-vue-修改属性也是异步"><span>4.2 vue 修改属性也是异步</span></a></h3><ul><li>效果、原因和 <code>setState</code> 一样</li></ul><h3 id="_4-3-setstate-的过程" tabindex="-1"><a class="header-anchor" href="#_4-3-setstate-的过程"><span>4.3 setState 的过程</span></a></h3><ul><li>每个组件实例，都有<code>renderComponent</code> 方法</li><li>执行 <code>renderComponent</code> 会重新执行实例的 <code>render</code></li><li><code>render</code> 函数返回 <code>newVnode</code> ，然后拿到 <code>preVnode</code></li><li>执行 <code>patch(preVnode, newVnode)</code></li></ul><h2 id="五、react-vs-vue" tabindex="-1"><a class="header-anchor" href="#五、react-vs-vue"><span>五、React vs vue</span></a></h2><h3 id="_5-1-两者的本质区别" tabindex="-1"><a class="header-anchor" href="#_5-1-两者的本质区别"><span>5.1 两者的本质区别</span></a></h3><ul><li>vue - 本质是 MVVM 框架，由 MVC 发展而来</li><li>React - 本质是前端组件化框架，由后端组件化发展而来</li><li>但这并不妨碍他们两者都能实现相同的功能</li></ul><h3 id="_5-2-看模板和组件化的区别" tabindex="-1"><a class="header-anchor" href="#_5-2-看模板和组件化的区别"><span>5.2 看模板和组件化的区别</span></a></h3><ul><li><code>vue</code>- 使用模板（最初由 <code>angular</code> 提出）</li><li><code>React</code>- 使用 <code>JSX</code></li><li>模板语法上，我更加倾向于 <code>JSX</code></li><li>模板分离上，我更加倾向于 <code>vue</code></li></ul><p><strong>模板的区别</strong></p><blockquote><p>模板应该和 JS 逻辑分离</p></blockquote><p><img src="'+v+'" alt="img"></p><p><img src="'+B+'" alt="img"></p><p><img src="'+E+'" alt="img"></p><p><strong>组件化区别</strong></p><ul><li><code>React</code> 本身就是组件化，没有组件化就不是 <code>React</code></li><li><code>vue</code> 也支持组件化，不过是在 <code>MVVM</code> 上的扩展</li><li>对于组件化，我更加倾向于 <code>React</code> ，做的彻底而清晰</li></ul><h3 id="_5-3-两者共同点" tabindex="-1"><a class="header-anchor" href="#_5-3-两者共同点"><span>5.3 两者共同点</span></a></h3><ul><li>都支持组件化</li><li>都是数据驱动试图</li></ul><p>阅读全文</p>',58),x=[w];function S(f,A){return i(),t("div",null,x)}const J=e(k,[["render",S],["__file","综合-06-前端面试之组件化.html.vue"]]),j=JSON.parse('{"path":"/%E7%BB%BC%E5%90%88-06-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96.html","title":"","lang":"zh-CN","frontmatter":{"description":"原文链接: https://interview.poetries.top/principle-docs/comprehensive/06-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96.html img 一、说一下对组件化的理解 1.1 组件的封装 视图 ...","head":[["meta",{"property":"og:url","content":"https://interview.leeguoo.com/%E7%BB%BC%E5%90%88-06-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"前端面试题集锦"}],["meta",{"property":"og:description","content":"原文链接: https://interview.poetries.top/principle-docs/comprehensive/06-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96.html img 一、说一下对组件化的理解 1.1 组件的封装 视图 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_56.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-06T05:59:31.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-06T05:59:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_56.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_57.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_58.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_59.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_60.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_61.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_62.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_63.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_64.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_65.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_66.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_67.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_68.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_69.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_70.png\\",\\"https://interview.leeguoo.com/images/s_poetries_work_gitee_2019_10_71.png\\"],\\"dateModified\\":\\"2024-06-06T05:59:31.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"一、说一下对组件化的理解","slug":"一、说一下对组件化的理解","link":"#一、说一下对组件化的理解","children":[{"level":3,"title":"1.1 组件的封装","slug":"_1-1-组件的封装","link":"#_1-1-组件的封装","children":[]},{"level":3,"title":"1.2 组件的复用","slug":"_1-2-组件的复用","link":"#_1-2-组件的复用","children":[]}]},{"level":2,"title":"二、JSX 本质是什么","slug":"二、jsx-本质是什么","link":"#二、jsx-本质是什么","children":[{"level":3,"title":"2.1 JSX 语法","slug":"_2-1-jsx-语法","link":"#_2-1-jsx-语法","children":[]},{"level":3,"title":"2.2 JSX 解析","slug":"_2-2-jsx-解析","link":"#_2-2-jsx-解析","children":[]},{"level":3,"title":"2.3 JSX 独立的标准","slug":"_2-3-jsx-独立的标准","link":"#_2-3-jsx-独立的标准","children":[]}]},{"level":2,"title":"三、JSX 和 vdom 的关系","slug":"三、jsx-和-vdom-的关系","link":"#三、jsx-和-vdom-的关系","children":[{"level":3,"title":"3.1 为何需要 vdom","slug":"_3-1-为何需要-vdom","link":"#_3-1-为何需要-vdom","children":[]},{"level":3,"title":"3.2 React.createElement 和 h","slug":"_3-2-react-createelement-和-h","link":"#_3-2-react-createelement-和-h","children":[]},{"level":3,"title":"3.3 何时 patch","slug":"_3-3-何时-patch","link":"#_3-3-何时-patch","children":[]},{"level":3,"title":"3.4 自定义组件的解析","slug":"_3-4-自定义组件的解析","link":"#_3-4-自定义组件的解析","children":[]}]},{"level":2,"title":"四、说一下 React setState 的过程","slug":"四、说一下-react-setstate-的过程","link":"#四、说一下-react-setstate-的过程","children":[{"level":3,"title":"4.1 setState 的异步","slug":"_4-1-setstate-的异步","link":"#_4-1-setstate-的异步","children":[]},{"level":3,"title":"4.2 vue 修改属性也是异步","slug":"_4-2-vue-修改属性也是异步","link":"#_4-2-vue-修改属性也是异步","children":[]},{"level":3,"title":"4.3 setState 的过程","slug":"_4-3-setstate-的过程","link":"#_4-3-setstate-的过程","children":[]}]},{"level":2,"title":"五、React vs vue","slug":"五、react-vs-vue","link":"#五、react-vs-vue","children":[{"level":3,"title":"5.1 两者的本质区别","slug":"_5-1-两者的本质区别","link":"#_5-1-两者的本质区别","children":[]},{"level":3,"title":"5.2 看模板和组件化的区别","slug":"_5-2-看模板和组件化的区别","link":"#_5-2-看模板和组件化的区别","children":[]},{"level":3,"title":"5.3 两者共同点","slug":"_5-3-两者共同点","link":"#_5-3-两者共同点","children":[]}]}],"git":{"updatedTime":1717653571000,"contributors":[{"name":"guoli","email":"guoli@zhihu.com","commits":1}]},"autoDesc":true,"filePathRelative":"综合-06-前端面试之组件化.md","excerpt":"<p>原文链接: <a href=\\"https://interview.poetries.top/principle-docs/comprehensive/06-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://interview.poetries.top/principle-docs/comprehensive/06-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96.html</a></p>"}');export{J as comp,j as data};
