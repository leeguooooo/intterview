<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.13" />
    <style>
      :root {
        --c-bg: #fff;
      }

      html.dark {
        --c-bg: #22272e;
      }

      html,
      body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches
      if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
        document.documentElement.classList.toggle('dark', true)
      }
    </script>
    <meta property="og:url" content="https://interview.leeguoo.com/React-19-ReactDOM-render-%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%B2%E8%81%94%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E7%9A%84.html"><meta property="og:site_name" content="前端面试题集锦"><meta property="og:description" content="原文链接: https://interview.poetries.top/principle-docs/react/19-ReactDOM.render%20%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%B2%E8%81%94%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E7%9A%84.html 从本..."><meta property="og:type" content="article"><meta property="og:image" content="https://interview.leeguoo.com/images/s_poetries_work_images_20210501195335.png"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-06-06T05:59:31.000Z"><meta property="article:modified_time" content="2024-06-06T05:59:31.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"","image":["https://interview.leeguoo.com/images/s_poetries_work_images_20210501195335.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501195353.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501195414.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501195521.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501195705.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501200309.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501201153.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501201231.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501201327.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501201544.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501211335.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501212348.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501212616.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501212641.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501212753.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501214149.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501214428.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501214533.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501214757.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501215239.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501215505.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501215910.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501220545.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501220749.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501220845.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501220908.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221024.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221052.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221125.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221222.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221423.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221451.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221508.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221520.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221536.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221636.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221716.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221727.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221737.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210501221811.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210502090820.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210502090847.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210502091049.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210502091118.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210502091323.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210502091538.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210502091827.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210502091913.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210502092000.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210502092206.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210502092259.png","https://interview.leeguoo.com/images/s_poetries_work_images_20210502092337.png"],"dateModified":"2024-06-06T05:59:31.000Z","author":[]}</script><link rel="stylesheet" href="/safe-area.css"><link rel="manifest" href="/manifest.json"><meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"><meta name="theme-color" content="#3eaf7c"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="apple-touch-icon" href="/images/icons/icon-152x152.png"><link rel="mask-icon" href="/images/icons/safari-pinned-tab.svg" color="#3eaf7c"><meta name="msapplication-TileImage" content="/images/icons/icon-144x144.png"><meta name="msapplication-TileColor" content="#000000"><link rel="icon" href="images/Favicons/favicon-32.png"><title>前端面试题集锦</title><meta name="description" content="原文链接: https://interview.poetries.top/principle-docs/react/19-ReactDOM.render%20%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%B2%E8%81%94%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E7%9A%84.html 从本...">
    <link rel="preload" href="/assets/style-DNXK5-Yl.css" as="style"><link rel="stylesheet" href="/assets/style-DNXK5-Yl.css">
    <link rel="modulepreload" href="/assets/app-f2Cpj3V4.js"><link rel="modulepreload" href="/assets/React-19-ReactDOM-render-是如何串联渲染链路的.html-C4B80Yqt.js">
    
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container"><!--[--><header class="vp-navbar"><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><img class="vp-site-logo" src="/images/logo.webp" alt="前端面试题集锦"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">前端面试题集锦</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="首页"><!---->首页<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="题库"><span class="title">题库</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="题库"><span class="title">题库</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%9F%BA%E7%A1%80%E7%AF%87.html" aria-label="基础篇"><!---->基础篇<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E8%BF%9B%E9%98%B6%E7%AF%87.html" aria-label="进阶篇"><!---->进阶篇<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E9%AB%98%E9%A2%91%E7%AF%87.html" aria-label="高频篇"><!---->高频篇<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/HTML.html" aria-label="HTML"><!---->HTML<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/CSS.html" aria-label="CSS"><!---->CSS<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/JavaScript.html" aria-label="JavaScript"><!---->JavaScript<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/ES6.html" aria-label="ES6"><!---->ES6<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E6%B5%8F%E8%A7%88%E5%99%A8.html" aria-label="浏览器"><!---->浏览器<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React.html" aria-label="React"><!---->React<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue.html" aria-label="Vue"><!---->Vue<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Node.html" aria-label="Node"><!---->Node<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html" aria-label="前端工程化"><!---->前端工程化<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%A7%BB%E5%8A%A8%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91.html" aria-label="移动多端开发"><!---->移动多端开发<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%B0%8F%E7%A8%8B%E5%BA%8F.html" aria-label="小程序"><!---->小程序<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Uniapp.html" aria-label="Uniapp"><!---->Uniapp<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8.html" aria-label="前端安全"><!---->前端安全<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" aria-label="性能优化"><!---->性能优化<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/HTTP.html" aria-label="HTTP"><!---->HTTP<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" aria-label="常用设计模式"><!---->常用设计模式<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%202.html" aria-label="设计模式 2"><!---->设计模式 2<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html" aria-label="框架通识"><!---->框架通识<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" aria-label="排序算法"><!---->排序算法<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86.html" aria-label="计算机通识"><!---->计算机通识<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Vue 源码解析"><span class="title">Vue 源码解析</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Vue 源码解析"><span class="title">Vue 源码解析</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue%E6%BA%90%E7%A0%81.html" aria-label="Vue-生命周期"><!---->Vue-生命周期<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8.html" aria-label="Vue-组件的本质"><!---->Vue-组件的本质<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.html" aria-label="Vue-有状态组件的设计"><!---->Vue-有状态组件的设计<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-VNode.html" aria-label="Vue-VNode"><!---->Vue-VNode<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E8%BE%85%E5%8A%A9%E5%88%9B%E5%BB%BA%20VNode%20%E7%9A%84%20h%20%E5%87%BD%E6%95%B0.html" aria-label="Vue-辅助创建VNode的h函数"><!---->Vue-辅助创建VNode的h函数<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8C%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93.html" aria-label="Vue-自定义渲染器和异步渲染"><!---->Vue-自定义渲染器和异步渲染<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html" aria-label="Vue-渲染器之挂载"><!---->Vue-渲染器之挂载<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%20Diff%20%E7%AE%97%E6%B3%95.html" aria-label="Vue-渲染器的核心 Diff 算法"><!---->Vue-渲染器的核心 Diff 算法<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%20patch.html" aria-label="Vue-渲染器之patch"><!---->Vue-渲染器之patch<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E5%9B%BE%E8%A7%A3%20Vue%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html" aria-label="Vue-图解 Vue 响应式原理"><!---->Vue-图解 Vue 响应式原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E5%9B%BE%E8%A7%A3%20Vue%20%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0.html" aria-label="Vue-图解 Vue 异步更新"><!---->Vue-图解 Vue 异步更新<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E5%89%96%E6%9E%90%20Vue%20%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html" aria-label="Vue-剖析 Vue 内部运行机制"><!---->Vue-剖析 Vue 内部运行机制<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%A8%A1%E6%8B%9F.html" aria-label="Vue-vue响应式原理模拟"><!---->Vue-vue响应式原理模拟<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B9%8Bvuex.html" aria-label="Vue-vue状态管理之vuex"><!---->Vue-vue状态管理之vuex<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E7%90%86%E8%A7%A3Vue%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E5%8F%8A%E5%AE%9E%E7%8E%B0Vue.html" aria-label="Vue-理解Vue的设计思想及实现Vue"><!---->Vue-理解Vue的设计思想及实现Vue<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-diff%E7%AE%97%E6%B3%95%E6%B7%B1%E5%85%A5.html" aria-label="Vue-diff算法深入"><!---->Vue-diff算法深入<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-vue%20router%20vuex%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html" aria-label="Vue-vue router vuex原理分析"><!---->Vue-vue router vuex原理分析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-Vue3%E5%88%9D%E6%8E%A2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86..html" aria-label="Vue-Vue3初探响应式原理."><!---->Vue-Vue3初探响应式原理.<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-vue2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" aria-label="Vue-vue2源码分析"><!---->Vue-vue2源码分析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5.html" aria-label="Vue-vue组件化实践"><!---->Vue-vue组件化实践<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/article/" aria-label="文章"><!---->文章<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/category/" aria-label="分类"><!---->分类<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tag/" aria-label="标签"><!---->标签<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/timeline/" aria-label="时间线"><!---->时间线<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="React"><span class="title">React</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="React"><span class="title">React</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-React%20router%E5%8E%9F%E7%90%86.html" aria-label="React-React router原理"><!---->React-React router原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-dva%20%E6%80%BB%E7%BB%93.html" aria-label="React-dva 总结"><!---->React-dva 总结<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-Mobx%20%E6%80%BB%E7%BB%93.html" aria-label="React-Mobx 总结"><!---->React-Mobx 总结<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-%E6%B5%85%E6%9E%90redux%20saga%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E7%94%A8%E6%B3%95.html" aria-label="React-浅析redux saga中间件及用法"><!---->React-浅析redux saga中间件及用法<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-Redux%E4%B9%8B%E6%B5%85%E6%9E%90%E4%B8%AD%E9%97%B4%E4%BB%B6.html" aria-label="React-Redux之浅析中间件"><!---->React-Redux之浅析中间件<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-Redux%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" aria-label="React-Redux之源码分析"><!---->React-Redux之源码分析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-Redux%E4%B9%8B%E5%BC%82%E6%AD%A5Action%E5%8F%8A%E6%93%8D%E4%BD%9C.html" aria-label="React-Redux之异步Action及操作"><!---->React-Redux之异步Action及操作<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-%E6%B5%85%E6%9E%90%E4%B8%AD%E9%97%B4%E4%BB%B6.html" aria-label="React-浅析中间件"><!---->React-浅析中间件<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-react%E7%BB%93%E5%90%88redux%E5%AE%9E%E6%88%98.html" aria-label="React-react结合redux实战"><!---->React-react结合redux实战<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-Immutable%E6%80%BB%E7%BB%93.html" aria-label="React-Immutable总结"><!---->React-Immutable总结<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8A.html" aria-label="React-React16为什么要更改生命周期上"><!---->React-React16为什么要更改生命周期上<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8B.html" aria-label="React-React16为什么要更改生命周期下"><!---->React-React16为什么要更改生命周期下<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-React%20Hooks%20%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.html" aria-label="React-React Hooks 设计动机与工作模式"><!---->React-React Hooks 设计动机与工作模式<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-%E6%B7%B1%E5%85%A5%20React%20Hooks%20%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.html" aria-label="React-深入 React Hooks 工作机制"><!---->React-深入 React Hooks 工作机制<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-15-%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM.html" aria-label="React-15-真正理解虚拟DOM"><!---->React-15-真正理解虚拟DOM<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-17-setState-%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84-%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84.html" aria-label="React-17-setState-到底是同步的-还是异步的"><!---->React-17-setState-到底是同步的-还是异步的<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-16-React-%E4%B8%AD%E7%9A%84-%E6%A0%88%E8%B0%83%E5%92%8C-Stack-Reconciler-%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84.html" aria-label="React-16-React-中的-栈调和-Stack-Reconciler-过程是怎样的"><!---->React-16-React-中的-栈调和-Stack-Reconciler-过程是怎样的<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-18-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Fiber-%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%8A%A8%E6%9C%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.html" aria-label="React-18-如何理解-Fiber-架构的迭代动机与设计思想"><!---->React-18-如何理解-Fiber-架构的迭代动机与设计思想<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/React-19-ReactDOM-render-%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%B2%E8%81%94%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E7%9A%84.html" aria-label="React-19-ReactDOM-render-是如何串联渲染链路的"><!---->React-19-ReactDOM-render-是如何串联渲染链路的<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-20-%E5%89%96%E6%9E%90-Fiber-%E6%9E%B6%E6%9E%84%E4%B8%8B-Concurrent-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" aria-label="React-20-剖析-Fiber-架构下-Concurrent-模式的实现原理"><!---->React-20-剖析-Fiber-架构下-Concurrent-模式的实现原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-21-React-%E4%BA%8B%E4%BB%B6%E4%B8%8E-DOM-%E4%BA%8B%E4%BB%B6%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C.html" aria-label="React-21-React-事件与-DOM-事件有何不同"><!---->React-21-React-事件与-DOM-事件有何不同<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-22-%E6%8F%AD%E7%A7%98-Redux-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html" aria-label="React-22-揭秘-Redux-设计思想与工作原理"><!---->React-22-揭秘-Redux-设计思想与工作原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-23-%E4%BB%8E-Redux-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%87%E5%85%A5-%E7%90%86%E8%A7%A3-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-.html" aria-label="React-23-从-Redux-中间件实现原理切入-理解-面向切面编程-"><!---->React-23-从-Redux-中间件实现原理切入-理解-面向切面编程-<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-24-%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84-React-%E5%BA%94%E7%94%A8.html" aria-label="React-24-如何打造高性能的-React-应用"><!---->React-24-如何打造高性能的-React-应用<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-25-%E8%B7%9F-React-%E5%AD%A6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" aria-label="React-25-跟-React-学设计模式"><!---->React-25-跟-React-学设计模式<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-26-React%E5%85%A8%E9%83%A8api%E8%A7%A3%E8%AF%BB.html" aria-label="React-26-React全部api解读"><!---->React-26-React全部api解读<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-27-Taro%E5%8E%9F%E7%90%86.html" aria-label="React-27-Taro原理"><!---->React-27-Taro原理<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Webpack"><span class="title">Webpack</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Webpack"><span class="title">Webpack</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-01-Webpack4%E6%89%93%E5%8C%85%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html" aria-label="Webpack-01-Webpack4打包机制原理解析"><!---->Webpack-01-Webpack4打包机制原理解析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-02-webpack%E4%B8%AD%E7%9A%84HMR%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.html" aria-label="Webpack-02-webpack中的HMR热更新原理剖析"><!---->Webpack-02-webpack中的HMR热更新原理剖析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-03-%E4%BB%8E%E6%BA%90%E7%A0%81%E7%AA%A5%E6%8E%A2Webpack4-x%E5%8E%9F%E7%90%86.html" aria-label="Webpack-03-从源码窥探Webpack4-x原理"><!---->Webpack-03-从源码窥探Webpack4-x原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-04-%E5%AE%9E%E7%8E%B0webpack%E5%B0%8F%E5%9E%8B%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7.html" aria-label="Webpack-04-实现webpack小型打包工具"><!---->Webpack-04-实现webpack小型打包工具<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-05-Babel%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html" aria-label="Webpack-05-Babel原理及其使用"><!---->Webpack-05-Babel原理及其使用<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-06-Webpack-%E4%B8%8E-Rollup-%E4%BA%8C%E8%80%85%E4%B9%8B%E9%97%B4%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9.html" aria-label="Webpack-06-Webpack-与-Rollup-二者之间该如何选择"><!---->Webpack-06-Webpack-与-Rollup-二者之间该如何选择<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-07-%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E6%96%B0%E7%8E%A9%E6%B3%95-Vite-%E4%B8%8A%E6%89%8B%E4%B8%8E%E6%80%9D%E8%80%83.html" aria-label="Webpack-07-前端构建新玩法-Vite-上手与思考"><!---->Webpack-07-前端构建新玩法-Vite-上手与思考<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-08-%E5%88%A9%E7%94%A8-Webpack-CodeSplitting-%E5%AE%8C%E6%88%90%E5%A4%8D%E6%9D%82%E5%BA%94%E7%94%A8%E6%8B%86%E5%8C%85.html" aria-label="Webpack-08-利用-Webpack-CodeSplitting-完成复杂应用拆包"><!---->Webpack-08-利用-Webpack-CodeSplitting-完成复杂应用拆包<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-09-%E7%8E%A9%E8%BD%AC-Webpack-%E7%9A%84-TreeShaking-%E4%B8%8E-sideEffects-%E7%89%B9%E6%80%A7.html" aria-label="Webpack-09-玩转-Webpack-的-TreeShaking-与-sideEffects-特性"><!---->Webpack-09-玩转-Webpack-的-TreeShaking-与-sideEffects-特性<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-10-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-Webpack-SourceMap-%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html" aria-label="Webpack-10-如何配置-Webpack-SourceMap-的最佳实践"><!---->Webpack-10-如何配置-Webpack-SourceMap-的最佳实践<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-11-Webpack-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html" aria-label="Webpack-11-Webpack-运行机制与核心工作原理"><!---->Webpack-11-Webpack-运行机制与核心工作原理<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Node"><span class="title">Node</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Node"><span class="title">Node</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Node-01-Node%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86.html" aria-label="Node-01-Node事件循环机制原理"><!---->Node-01-Node事件循环机制原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Node-02-express%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8.html" aria-label="Node-02-express详细使用"><!---->Node-02-express详细使用<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Node-03-koa%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.html" aria-label="Node-03-koa基本用法"><!---->Node-03-koa基本用法<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Javascript"><span class="title">Javascript</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Javascript"><span class="title">Javascript</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Javascript-01-JavaScript-%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C-JavaScript-%E4%BB%A3%E7%A0%81.html" aria-label="Javascript-01-JavaScript-引擎如何执行-JavaScript-代码"><!---->Javascript-01-JavaScript-引擎如何执行-JavaScript-代码<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Javascript-02-%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84-JavaScript-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1.html" aria-label="Javascript-02-单线程的-JavaScript-如何管理任务"><!---->Javascript-02-单线程的-JavaScript-如何管理任务<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="综合"><span class="title">综合</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="综合"><span class="title">综合</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%80%E4%B9%88%E6%98%AF-virtual-dom.html" aria-label="综合-01-虚拟DOM原理分析-什么是-virtual-dom"><!---->综合-01-虚拟DOM原理分析-什么是-virtual-dom<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-02-setTimeout%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F.html" aria-label="综合-02-setTimeout实现原理和使用注意"><!---->综合-02-setTimeout实现原理和使用注意<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-03-%E6%B5%85%E6%9E%90Promise%E5%8E%9F%E7%90%86.html" aria-label="综合-03-浅析Promise原理"><!---->综合-03-浅析Promise原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-04-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.html" aria-label="综合-04-浏览器渲染原理"><!---->综合-04-浏览器渲染原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-05-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BMVVM%E6%B5%85%E6%9E%90.html" aria-label="综合-05-前端面试之MVVM浅析"><!---->综合-05-前端面试之MVVM浅析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-06-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96.html" aria-label="综合-06-前端面试之组件化"><!---->综合-06-前端面试之组件化<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-07-%E8%99%9A%E6%8B%9FDOM-%E4%B8%80-.html" aria-label="综合-07-虚拟DOM-一-"><!---->综合-07-虚拟DOM-一-<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-08-%E8%99%9A%E6%8B%9FDOM-%E4%BA%8C-.html" aria-label="综合-08-虚拟DOM-二-"><!---->综合-08-虚拟DOM-二-<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-09-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8BPerformance.html" aria-label="综合-09-前端性能之Performance"><!---->综合-09-前端性能之Performance<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-10-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5.html" aria-label="综合-10-小程序开发实践"><!---->综合-10-小程序开发实践<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-11-%E5%AF%B9%E6%AF%94-Koa-%E5%92%8C-Redux-%E5%88%86%E6%9E%90%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%90%86%E5%BF%B5.html" aria-label="综合-11-对比-Koa-和-Redux-分析前端中的中间件理念"><!---->综合-11-对比-Koa-和-Redux-分析前端中的中间件理念<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-12-%E6%AD%A3%E5%88%99%E5%AE%8C%E6%95%B4%E7%AF%87.html" aria-label="综合-12-正则完整篇"><!---->综合-12-正则完整篇<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-13-%E6%89%93%E9%80%A0%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F.html" aria-label="综合-13-打造前端监控系统"><!---->综合-13-打造前端监控系统<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-14-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.html" aria-label="综合-14-浏览器渲染机制"><!---->综合-14-浏览器渲染机制<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-15-%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90.html" aria-label="综合-15-前端缓存方案解析"><!---->综合-15-前端缓存方案解析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-16-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%90%86.html" aria-label="综合-16-小程序原理"><!---->综合-16-小程序原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-17-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.html" aria-label="综合-17-深入剖析浏览器中页面的渲染过程"><!---->综合-17-深入剖析浏览器中页面的渲染过程<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-18-%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E7%9A%84.html" aria-label="综合-18-一个网络请求是怎么进行的"><!---->综合-18-一个网络请求是怎么进行的<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-19-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E5%AE%9A%E4%BD%8D.html" aria-label="综合-19-前端性能定位"><!---->综合-19-前端性能定位<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="面经"><span class="title">面经</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="面经"><span class="title">面经</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E9%9D%A2%E7%BB%8F-%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB.html" aria-label="面经-前端面经汇总"><!---->面经-前端面经汇总<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="自检"><span class="title">自检</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="自检"><span class="title">自检</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E8%87%AA%E6%A3%80-1-%E5%89%8D%E7%AB%AF100%E9%A2%98%E8%87%AA%E6%A3%80.html" aria-label="自检-1-前端100题自检"><!---->自检-1-前端100题自检<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="每日一题"><span class="title">每日一题</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="每日一题"><span class="title">每日一题</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98.html" aria-label="每日一题-每日一题"><!---->每日一题-每日一题<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="http 基础"><span class="title">http 基础</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="http 基础"><span class="title">http 基础</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-01-HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.html" aria-label="http 基础-01-HTTP的前世今生"><!---->http 基础-01-HTTP的前世今生<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-02-HTTP%E6%98%AF%E4%BB%80%E4%B9%88.html" aria-label="http 基础-02-HTTP是什么"><!---->http 基础-02-HTTP是什么<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-03-HTTP%E4%B8%96%E7%95%8C%E5%85%A8%E8%A7%88.html" aria-label="http 基础-03-HTTP世界全览"><!---->http 基础-03-HTTP世界全览<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-04-HTTP%E5%88%86%E5%B1%82.html" aria-label="http 基础-04-HTTP分层"><!---->http 基础-04-HTTP分层<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-05-%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E5%9B%9E%E8%BD%A6%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88.html" aria-label="http 基础-05-键入网址到回车发生什么"><!---->http 基础-05-键入网址到回车发生什么<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-06-HTTP%E6%8A%A5%E6%96%87%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84.html" aria-label="http 基础-06-HTTP报文是什么样子的"><!---->http 基础-06-HTTP报文是什么样子的<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-07-%E7%90%86%E8%A7%A3%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95.html" aria-label="http 基础-07-理解请求方法"><!---->http 基础-07-理解请求方法<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-08-URI.html" aria-label="http 基础-08-URI"><!---->http 基础-08-URI<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-09-%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81.html" aria-label="http 基础-09-响应状态码"><!---->http 基础-09-响应状态码<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-10-HTTP%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9.html" aria-label="http 基础-10-HTTP有哪些特点"><!---->http 基础-10-HTTP有哪些特点<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-11-HTTP%E4%BC%98%E7%BC%BA%E7%82%B9.html" aria-label="http 基础-11-HTTP优缺点"><!---->http 基础-11-HTTP优缺点<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-12-HTTP%E7%9A%84%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE.html" aria-label="http 基础-12-HTTP的实体数据"><!---->http 基础-12-HTTP的实体数据<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-13-HTTP%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6.html" aria-label="http 基础-13-HTTP传输大文件"><!---->http 基础-13-HTTP传输大文件<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-14-HTTP%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86.html" aria-label="http 基础-14-HTTP的连接管理"><!---->http 基础-14-HTTP的连接管理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-15-HTTP%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91.html" aria-label="http 基础-15-HTTP的重定向"><!---->http 基础-15-HTTP的重定向<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-16-HTTP%E7%9A%84Cookie%E6%9C%BA%E5%88%B6.html" aria-label="http 基础-16-HTTP的Cookie机制"><!---->http 基础-16-HTTP的Cookie机制<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-17-HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6.html" aria-label="http 基础-17-HTTP的缓存控制"><!---->http 基础-17-HTTP的缓存控制<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-18-HTTP%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1.html" aria-label="http 基础-18-HTTP的代理服务"><!---->http 基础-18-HTTP的代理服务<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-19-HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86.html" aria-label="http 基础-19-HTTP的缓存代理"><!---->http 基础-19-HTTP的缓存代理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-20-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.html" aria-label="http 基础-20-对称加密与非对称加密"><!---->http 基础-20-对称加密与非对称加密<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-21-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8E%E8%AF%81%E4%B9%A6.html" aria-label="http 基础-21-数字签名与证书"><!---->http 基础-21-数字签名与证书<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-22-TLS1-2%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90.html" aria-label="http 基础-22-TLS1-2连接过程解析"><!---->http 基础-22-TLS1-2连接过程解析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-23-TLS1-3%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90.html" aria-label="http 基础-23-TLS1-3特性解析"><!---->http 基础-23-TLS1-3特性解析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-24-HTTPS%E7%9A%84%E4%BC%98%E5%8C%96.html" aria-label="http 基础-24-HTTPS的优化"><!---->http 基础-24-HTTPS的优化<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-25-%E8%BF%81%E7%A7%BB%E5%88%B0HTTPS.html" aria-label="http 基础-25-迁移到HTTPS"><!---->http 基础-25-迁移到HTTPS<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-26-HTTP2%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88.html" aria-label="http 基础-26-HTTP2特性概览"><!---->http 基础-26-HTTP2特性概览<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-27-HTTP3%E5%B1%95%E6%9C%9B.html" aria-label="http 基础-27-HTTP3展望"><!---->http 基础-27-HTTP3展望<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-28-%E8%BF%81%E7%A7%BB%E5%88%B0HTTP2.html" aria-label="http 基础-28-迁移到HTTP2"><!---->http 基础-28-迁移到HTTP2<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-29-CDN.html" aria-label="http 基础-29-CDN"><!---->http 基础-29-CDN<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-30-webSocket.html" aria-label="http 基础-30-webSocket"><!---->http 基础-30-webSocket<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-31-HTTP%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8A.html" aria-label="http 基础-31-HTTP性能优化上"><!---->http 基础-31-HTTP性能优化上<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-32-HTTP%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8B.html" aria-label="http 基础-32-HTTP性能优化下"><!---->http 基础-32-HTTP性能优化下<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="学习路线"><span class="title">学习路线</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="学习路线"><span class="title">学习路线</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-frontend.html" aria-label="学习路线-frontend"><!---->学习路线-frontend<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-backend.html" aria-label="学习路线-backend"><!---->学习路线-backend<!----></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><button class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar"><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="首页"><!---->首页<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="题库"><span class="title">题库</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="题库"><span class="title">题库</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%9F%BA%E7%A1%80%E7%AF%87.html" aria-label="基础篇"><!---->基础篇<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E8%BF%9B%E9%98%B6%E7%AF%87.html" aria-label="进阶篇"><!---->进阶篇<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E9%AB%98%E9%A2%91%E7%AF%87.html" aria-label="高频篇"><!---->高频篇<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/HTML.html" aria-label="HTML"><!---->HTML<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/CSS.html" aria-label="CSS"><!---->CSS<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/JavaScript.html" aria-label="JavaScript"><!---->JavaScript<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/ES6.html" aria-label="ES6"><!---->ES6<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E6%B5%8F%E8%A7%88%E5%99%A8.html" aria-label="浏览器"><!---->浏览器<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React.html" aria-label="React"><!---->React<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue.html" aria-label="Vue"><!---->Vue<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Node.html" aria-label="Node"><!---->Node<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html" aria-label="前端工程化"><!---->前端工程化<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%A7%BB%E5%8A%A8%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91.html" aria-label="移动多端开发"><!---->移动多端开发<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%B0%8F%E7%A8%8B%E5%BA%8F.html" aria-label="小程序"><!---->小程序<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Uniapp.html" aria-label="Uniapp"><!---->Uniapp<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8.html" aria-label="前端安全"><!---->前端安全<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" aria-label="性能优化"><!---->性能优化<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/HTTP.html" aria-label="HTTP"><!---->HTTP<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" aria-label="常用设计模式"><!---->常用设计模式<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%202.html" aria-label="设计模式 2"><!---->设计模式 2<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86.html" aria-label="框架通识"><!---->框架通识<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html" aria-label="排序算法"><!---->排序算法<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86.html" aria-label="计算机通识"><!---->计算机通识<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Vue 源码解析"><span class="title">Vue 源码解析</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Vue 源码解析"><span class="title">Vue 源码解析</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue%E6%BA%90%E7%A0%81.html" aria-label="Vue-生命周期"><!---->Vue-生命周期<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8.html" aria-label="Vue-组件的本质"><!---->Vue-组件的本质<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.html" aria-label="Vue-有状态组件的设计"><!---->Vue-有状态组件的设计<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-VNode.html" aria-label="Vue-VNode"><!---->Vue-VNode<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E8%BE%85%E5%8A%A9%E5%88%9B%E5%BB%BA%20VNode%20%E7%9A%84%20h%20%E5%87%BD%E6%95%B0.html" aria-label="Vue-辅助创建VNode的h函数"><!---->Vue-辅助创建VNode的h函数<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8C%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93.html" aria-label="Vue-自定义渲染器和异步渲染"><!---->Vue-自定义渲染器和异步渲染<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%E6%8C%82%E8%BD%BD.html" aria-label="Vue-渲染器之挂载"><!---->Vue-渲染器之挂载<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%20Diff%20%E7%AE%97%E6%B3%95.html" aria-label="Vue-渲染器的核心 Diff 算法"><!---->Vue-渲染器的核心 Diff 算法<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B9%8B%20patch.html" aria-label="Vue-渲染器之patch"><!---->Vue-渲染器之patch<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E5%9B%BE%E8%A7%A3%20Vue%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html" aria-label="Vue-图解 Vue 响应式原理"><!---->Vue-图解 Vue 响应式原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E5%9B%BE%E8%A7%A3%20Vue%20%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0.html" aria-label="Vue-图解 Vue 异步更新"><!---->Vue-图解 Vue 异步更新<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E5%89%96%E6%9E%90%20Vue%20%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html" aria-label="Vue-剖析 Vue 内部运行机制"><!---->Vue-剖析 Vue 内部运行机制<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%A8%A1%E6%8B%9F.html" aria-label="Vue-vue响应式原理模拟"><!---->Vue-vue响应式原理模拟<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B9%8Bvuex.html" aria-label="Vue-vue状态管理之vuex"><!---->Vue-vue状态管理之vuex<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-%E7%90%86%E8%A7%A3Vue%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E5%8F%8A%E5%AE%9E%E7%8E%B0Vue.html" aria-label="Vue-理解Vue的设计思想及实现Vue"><!---->Vue-理解Vue的设计思想及实现Vue<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-diff%E7%AE%97%E6%B3%95%E6%B7%B1%E5%85%A5.html" aria-label="Vue-diff算法深入"><!---->Vue-diff算法深入<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-vue%20router%20vuex%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html" aria-label="Vue-vue router vuex原理分析"><!---->Vue-vue router vuex原理分析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-Vue3%E5%88%9D%E6%8E%A2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86..html" aria-label="Vue-Vue3初探响应式原理."><!---->Vue-Vue3初探响应式原理.<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-vue2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" aria-label="Vue-vue2源码分析"><!---->Vue-vue2源码分析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Vue-vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5.html" aria-label="Vue-vue组件化实践"><!---->Vue-vue组件化实践<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/article/" aria-label="文章"><!---->文章<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/category/" aria-label="分类"><!---->分类<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tag/" aria-label="标签"><!---->标签<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/timeline/" aria-label="时间线"><!---->时间线<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="React"><span class="title">React</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="React"><span class="title">React</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-React%20router%E5%8E%9F%E7%90%86.html" aria-label="React-React router原理"><!---->React-React router原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-dva%20%E6%80%BB%E7%BB%93.html" aria-label="React-dva 总结"><!---->React-dva 总结<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-Mobx%20%E6%80%BB%E7%BB%93.html" aria-label="React-Mobx 总结"><!---->React-Mobx 总结<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-%E6%B5%85%E6%9E%90redux%20saga%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8F%8A%E7%94%A8%E6%B3%95.html" aria-label="React-浅析redux saga中间件及用法"><!---->React-浅析redux saga中间件及用法<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-Redux%E4%B9%8B%E6%B5%85%E6%9E%90%E4%B8%AD%E9%97%B4%E4%BB%B6.html" aria-label="React-Redux之浅析中间件"><!---->React-Redux之浅析中间件<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-Redux%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" aria-label="React-Redux之源码分析"><!---->React-Redux之源码分析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-Redux%E4%B9%8B%E5%BC%82%E6%AD%A5Action%E5%8F%8A%E6%93%8D%E4%BD%9C.html" aria-label="React-Redux之异步Action及操作"><!---->React-Redux之异步Action及操作<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-%E6%B5%85%E6%9E%90%E4%B8%AD%E9%97%B4%E4%BB%B6.html" aria-label="React-浅析中间件"><!---->React-浅析中间件<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-react%E7%BB%93%E5%90%88redux%E5%AE%9E%E6%88%98.html" aria-label="React-react结合redux实战"><!---->React-react结合redux实战<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-Immutable%E6%80%BB%E7%BB%93.html" aria-label="React-Immutable总结"><!---->React-Immutable总结<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8A.html" aria-label="React-React16为什么要更改生命周期上"><!---->React-React16为什么要更改生命周期上<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8B.html" aria-label="React-React16为什么要更改生命周期下"><!---->React-React16为什么要更改生命周期下<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-React%20Hooks%20%E8%AE%BE%E8%AE%A1%E5%8A%A8%E6%9C%BA%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.html" aria-label="React-React Hooks 设计动机与工作模式"><!---->React-React Hooks 设计动机与工作模式<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-%E6%B7%B1%E5%85%A5%20React%20Hooks%20%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.html" aria-label="React-深入 React Hooks 工作机制"><!---->React-深入 React Hooks 工作机制<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-15-%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM.html" aria-label="React-15-真正理解虚拟DOM"><!---->React-15-真正理解虚拟DOM<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-17-setState-%E5%88%B0%E5%BA%95%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84-%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84.html" aria-label="React-17-setState-到底是同步的-还是异步的"><!---->React-17-setState-到底是同步的-还是异步的<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-16-React-%E4%B8%AD%E7%9A%84-%E6%A0%88%E8%B0%83%E5%92%8C-Stack-Reconciler-%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84.html" aria-label="React-16-React-中的-栈调和-Stack-Reconciler-过程是怎样的"><!---->React-16-React-中的-栈调和-Stack-Reconciler-过程是怎样的<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-18-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Fiber-%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%8A%A8%E6%9C%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.html" aria-label="React-18-如何理解-Fiber-架构的迭代动机与设计思想"><!---->React-18-如何理解-Fiber-架构的迭代动机与设计思想<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/React-19-ReactDOM-render-%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%B2%E8%81%94%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E7%9A%84.html" aria-label="React-19-ReactDOM-render-是如何串联渲染链路的"><!---->React-19-ReactDOM-render-是如何串联渲染链路的<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-20-%E5%89%96%E6%9E%90-Fiber-%E6%9E%B6%E6%9E%84%E4%B8%8B-Concurrent-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" aria-label="React-20-剖析-Fiber-架构下-Concurrent-模式的实现原理"><!---->React-20-剖析-Fiber-架构下-Concurrent-模式的实现原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-21-React-%E4%BA%8B%E4%BB%B6%E4%B8%8E-DOM-%E4%BA%8B%E4%BB%B6%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C.html" aria-label="React-21-React-事件与-DOM-事件有何不同"><!---->React-21-React-事件与-DOM-事件有何不同<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-22-%E6%8F%AD%E7%A7%98-Redux-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html" aria-label="React-22-揭秘-Redux-设计思想与工作原理"><!---->React-22-揭秘-Redux-设计思想与工作原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-23-%E4%BB%8E-Redux-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%87%E5%85%A5-%E7%90%86%E8%A7%A3-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-.html" aria-label="React-23-从-Redux-中间件实现原理切入-理解-面向切面编程-"><!---->React-23-从-Redux-中间件实现原理切入-理解-面向切面编程-<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-24-%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84-React-%E5%BA%94%E7%94%A8.html" aria-label="React-24-如何打造高性能的-React-应用"><!---->React-24-如何打造高性能的-React-应用<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-25-%E8%B7%9F-React-%E5%AD%A6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" aria-label="React-25-跟-React-学设计模式"><!---->React-25-跟-React-学设计模式<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-26-React%E5%85%A8%E9%83%A8api%E8%A7%A3%E8%AF%BB.html" aria-label="React-26-React全部api解读"><!---->React-26-React全部api解读<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/React-27-Taro%E5%8E%9F%E7%90%86.html" aria-label="React-27-Taro原理"><!---->React-27-Taro原理<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Webpack"><span class="title">Webpack</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Webpack"><span class="title">Webpack</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-01-Webpack4%E6%89%93%E5%8C%85%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html" aria-label="Webpack-01-Webpack4打包机制原理解析"><!---->Webpack-01-Webpack4打包机制原理解析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-02-webpack%E4%B8%AD%E7%9A%84HMR%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.html" aria-label="Webpack-02-webpack中的HMR热更新原理剖析"><!---->Webpack-02-webpack中的HMR热更新原理剖析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-03-%E4%BB%8E%E6%BA%90%E7%A0%81%E7%AA%A5%E6%8E%A2Webpack4-x%E5%8E%9F%E7%90%86.html" aria-label="Webpack-03-从源码窥探Webpack4-x原理"><!---->Webpack-03-从源码窥探Webpack4-x原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-04-%E5%AE%9E%E7%8E%B0webpack%E5%B0%8F%E5%9E%8B%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7.html" aria-label="Webpack-04-实现webpack小型打包工具"><!---->Webpack-04-实现webpack小型打包工具<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-05-Babel%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html" aria-label="Webpack-05-Babel原理及其使用"><!---->Webpack-05-Babel原理及其使用<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-06-Webpack-%E4%B8%8E-Rollup-%E4%BA%8C%E8%80%85%E4%B9%8B%E9%97%B4%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9.html" aria-label="Webpack-06-Webpack-与-Rollup-二者之间该如何选择"><!---->Webpack-06-Webpack-与-Rollup-二者之间该如何选择<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-07-%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E6%96%B0%E7%8E%A9%E6%B3%95-Vite-%E4%B8%8A%E6%89%8B%E4%B8%8E%E6%80%9D%E8%80%83.html" aria-label="Webpack-07-前端构建新玩法-Vite-上手与思考"><!---->Webpack-07-前端构建新玩法-Vite-上手与思考<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-08-%E5%88%A9%E7%94%A8-Webpack-CodeSplitting-%E5%AE%8C%E6%88%90%E5%A4%8D%E6%9D%82%E5%BA%94%E7%94%A8%E6%8B%86%E5%8C%85.html" aria-label="Webpack-08-利用-Webpack-CodeSplitting-完成复杂应用拆包"><!---->Webpack-08-利用-Webpack-CodeSplitting-完成复杂应用拆包<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-09-%E7%8E%A9%E8%BD%AC-Webpack-%E7%9A%84-TreeShaking-%E4%B8%8E-sideEffects-%E7%89%B9%E6%80%A7.html" aria-label="Webpack-09-玩转-Webpack-的-TreeShaking-与-sideEffects-特性"><!---->Webpack-09-玩转-Webpack-的-TreeShaking-与-sideEffects-特性<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-10-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-Webpack-SourceMap-%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html" aria-label="Webpack-10-如何配置-Webpack-SourceMap-的最佳实践"><!---->Webpack-10-如何配置-Webpack-SourceMap-的最佳实践<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Webpack-11-Webpack-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html" aria-label="Webpack-11-Webpack-运行机制与核心工作原理"><!---->Webpack-11-Webpack-运行机制与核心工作原理<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Node"><span class="title">Node</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Node"><span class="title">Node</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Node-01-Node%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86.html" aria-label="Node-01-Node事件循环机制原理"><!---->Node-01-Node事件循环机制原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Node-02-express%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8.html" aria-label="Node-02-express详细使用"><!---->Node-02-express详细使用<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Node-03-koa%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.html" aria-label="Node-03-koa基本用法"><!---->Node-03-koa基本用法<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Javascript"><span class="title">Javascript</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Javascript"><span class="title">Javascript</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Javascript-01-JavaScript-%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C-JavaScript-%E4%BB%A3%E7%A0%81.html" aria-label="Javascript-01-JavaScript-引擎如何执行-JavaScript-代码"><!---->Javascript-01-JavaScript-引擎如何执行-JavaScript-代码<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/Javascript-02-%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84-JavaScript-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1.html" aria-label="Javascript-02-单线程的-JavaScript-如何管理任务"><!---->Javascript-02-单线程的-JavaScript-如何管理任务<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="综合"><span class="title">综合</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="综合"><span class="title">综合</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-01-%E8%99%9A%E6%8B%9FDOM%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E4%BB%80%E4%B9%88%E6%98%AF-virtual-dom.html" aria-label="综合-01-虚拟DOM原理分析-什么是-virtual-dom"><!---->综合-01-虚拟DOM原理分析-什么是-virtual-dom<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-02-setTimeout%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F.html" aria-label="综合-02-setTimeout实现原理和使用注意"><!---->综合-02-setTimeout实现原理和使用注意<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-03-%E6%B5%85%E6%9E%90Promise%E5%8E%9F%E7%90%86.html" aria-label="综合-03-浅析Promise原理"><!---->综合-03-浅析Promise原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-04-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.html" aria-label="综合-04-浏览器渲染原理"><!---->综合-04-浏览器渲染原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-05-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BMVVM%E6%B5%85%E6%9E%90.html" aria-label="综合-05-前端面试之MVVM浅析"><!---->综合-05-前端面试之MVVM浅析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-06-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96.html" aria-label="综合-06-前端面试之组件化"><!---->综合-06-前端面试之组件化<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-07-%E8%99%9A%E6%8B%9FDOM-%E4%B8%80-.html" aria-label="综合-07-虚拟DOM-一-"><!---->综合-07-虚拟DOM-一-<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-08-%E8%99%9A%E6%8B%9FDOM-%E4%BA%8C-.html" aria-label="综合-08-虚拟DOM-二-"><!---->综合-08-虚拟DOM-二-<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-09-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8BPerformance.html" aria-label="综合-09-前端性能之Performance"><!---->综合-09-前端性能之Performance<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-10-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5.html" aria-label="综合-10-小程序开发实践"><!---->综合-10-小程序开发实践<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-11-%E5%AF%B9%E6%AF%94-Koa-%E5%92%8C-Redux-%E5%88%86%E6%9E%90%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%90%86%E5%BF%B5.html" aria-label="综合-11-对比-Koa-和-Redux-分析前端中的中间件理念"><!---->综合-11-对比-Koa-和-Redux-分析前端中的中间件理念<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-12-%E6%AD%A3%E5%88%99%E5%AE%8C%E6%95%B4%E7%AF%87.html" aria-label="综合-12-正则完整篇"><!---->综合-12-正则完整篇<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-13-%E6%89%93%E9%80%A0%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F.html" aria-label="综合-13-打造前端监控系统"><!---->综合-13-打造前端监控系统<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-14-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.html" aria-label="综合-14-浏览器渲染机制"><!---->综合-14-浏览器渲染机制<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-15-%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90.html" aria-label="综合-15-前端缓存方案解析"><!---->综合-15-前端缓存方案解析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-16-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%90%86.html" aria-label="综合-16-小程序原理"><!---->综合-16-小程序原理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-17-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.html" aria-label="综合-17-深入剖析浏览器中页面的渲染过程"><!---->综合-17-深入剖析浏览器中页面的渲染过程<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-18-%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E7%9A%84.html" aria-label="综合-18-一个网络请求是怎么进行的"><!---->综合-18-一个网络请求是怎么进行的<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E7%BB%BC%E5%90%88-19-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E5%AE%9A%E4%BD%8D.html" aria-label="综合-19-前端性能定位"><!---->综合-19-前端性能定位<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="面经"><span class="title">面经</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="面经"><span class="title">面经</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E9%9D%A2%E7%BB%8F-%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB.html" aria-label="面经-前端面经汇总"><!---->面经-前端面经汇总<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="自检"><span class="title">自检</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="自检"><span class="title">自检</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E8%87%AA%E6%A3%80-1-%E5%89%8D%E7%AB%AF100%E9%A2%98%E8%87%AA%E6%A3%80.html" aria-label="自检-1-前端100题自检"><!---->自检-1-前端100题自检<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="每日一题"><span class="title">每日一题</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="每日一题"><span class="title">每日一题</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98.html" aria-label="每日一题-每日一题"><!---->每日一题-每日一题<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="http 基础"><span class="title">http 基础</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="http 基础"><span class="title">http 基础</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-01-HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.html" aria-label="http 基础-01-HTTP的前世今生"><!---->http 基础-01-HTTP的前世今生<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-02-HTTP%E6%98%AF%E4%BB%80%E4%B9%88.html" aria-label="http 基础-02-HTTP是什么"><!---->http 基础-02-HTTP是什么<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-03-HTTP%E4%B8%96%E7%95%8C%E5%85%A8%E8%A7%88.html" aria-label="http 基础-03-HTTP世界全览"><!---->http 基础-03-HTTP世界全览<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-04-HTTP%E5%88%86%E5%B1%82.html" aria-label="http 基础-04-HTTP分层"><!---->http 基础-04-HTTP分层<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-05-%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E5%9B%9E%E8%BD%A6%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88.html" aria-label="http 基础-05-键入网址到回车发生什么"><!---->http 基础-05-键入网址到回车发生什么<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-06-HTTP%E6%8A%A5%E6%96%87%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84.html" aria-label="http 基础-06-HTTP报文是什么样子的"><!---->http 基础-06-HTTP报文是什么样子的<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-07-%E7%90%86%E8%A7%A3%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95.html" aria-label="http 基础-07-理解请求方法"><!---->http 基础-07-理解请求方法<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-08-URI.html" aria-label="http 基础-08-URI"><!---->http 基础-08-URI<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-09-%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81.html" aria-label="http 基础-09-响应状态码"><!---->http 基础-09-响应状态码<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-10-HTTP%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9.html" aria-label="http 基础-10-HTTP有哪些特点"><!---->http 基础-10-HTTP有哪些特点<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-11-HTTP%E4%BC%98%E7%BC%BA%E7%82%B9.html" aria-label="http 基础-11-HTTP优缺点"><!---->http 基础-11-HTTP优缺点<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-12-HTTP%E7%9A%84%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE.html" aria-label="http 基础-12-HTTP的实体数据"><!---->http 基础-12-HTTP的实体数据<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-13-HTTP%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6.html" aria-label="http 基础-13-HTTP传输大文件"><!---->http 基础-13-HTTP传输大文件<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-14-HTTP%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86.html" aria-label="http 基础-14-HTTP的连接管理"><!---->http 基础-14-HTTP的连接管理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-15-HTTP%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91.html" aria-label="http 基础-15-HTTP的重定向"><!---->http 基础-15-HTTP的重定向<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-16-HTTP%E7%9A%84Cookie%E6%9C%BA%E5%88%B6.html" aria-label="http 基础-16-HTTP的Cookie机制"><!---->http 基础-16-HTTP的Cookie机制<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-17-HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6.html" aria-label="http 基础-17-HTTP的缓存控制"><!---->http 基础-17-HTTP的缓存控制<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-18-HTTP%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1.html" aria-label="http 基础-18-HTTP的代理服务"><!---->http 基础-18-HTTP的代理服务<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-19-HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86.html" aria-label="http 基础-19-HTTP的缓存代理"><!---->http 基础-19-HTTP的缓存代理<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-20-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.html" aria-label="http 基础-20-对称加密与非对称加密"><!---->http 基础-20-对称加密与非对称加密<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-21-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8E%E8%AF%81%E4%B9%A6.html" aria-label="http 基础-21-数字签名与证书"><!---->http 基础-21-数字签名与证书<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-22-TLS1-2%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90.html" aria-label="http 基础-22-TLS1-2连接过程解析"><!---->http 基础-22-TLS1-2连接过程解析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-23-TLS1-3%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90.html" aria-label="http 基础-23-TLS1-3特性解析"><!---->http 基础-23-TLS1-3特性解析<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-24-HTTPS%E7%9A%84%E4%BC%98%E5%8C%96.html" aria-label="http 基础-24-HTTPS的优化"><!---->http 基础-24-HTTPS的优化<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-25-%E8%BF%81%E7%A7%BB%E5%88%B0HTTPS.html" aria-label="http 基础-25-迁移到HTTPS"><!---->http 基础-25-迁移到HTTPS<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-26-HTTP2%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88.html" aria-label="http 基础-26-HTTP2特性概览"><!---->http 基础-26-HTTP2特性概览<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-27-HTTP3%E5%B1%95%E6%9C%9B.html" aria-label="http 基础-27-HTTP3展望"><!---->http 基础-27-HTTP3展望<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-28-%E8%BF%81%E7%A7%BB%E5%88%B0HTTP2.html" aria-label="http 基础-28-迁移到HTTP2"><!---->http 基础-28-迁移到HTTP2<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-29-CDN.html" aria-label="http 基础-29-CDN"><!---->http 基础-29-CDN<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-30-webSocket.html" aria-label="http 基础-30-webSocket"><!---->http 基础-30-webSocket<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-31-HTTP%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8A.html" aria-label="http 基础-31-HTTP性能优化上"><!---->http 基础-31-HTTP性能优化上<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/http%20%E5%9F%BA%E7%A1%80-32-HTTP%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8B.html" aria-label="http 基础-32-HTTP性能优化下"><!---->http 基础-32-HTTP性能优化下<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="学习路线"><span class="title">学习路线</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="学习路线"><span class="title">学习路线</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-frontend.html" aria-label="学习路线-frontend"><!---->学习路线-frontend<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-backend.html" aria-label="学习路线-backend"><!---->学习路线-backend<!----></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading"> <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#一、reactdom-render-调用栈的逻辑分层" aria-label="一、ReactDOM.render 调用栈的逻辑分层"><!---->一、ReactDOM.render 调用栈的逻辑分层<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#二、初始化阶段" aria-label="二、初始化阶段"><!---->二、初始化阶段<!----></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#拆解-reactdom-render-调用栈——初始化阶段" aria-label="拆解 ReactDOM.render 调用栈——初始化阶段"><!---->拆解 ReactDOM.render 调用栈——初始化阶段<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#同步的-reactdom-render-异步的-reactdom-createroot" aria-label="同步的 ReactDOM.render，异步的 ReactDOM.createRoot"><!---->同步的 ReactDOM.render，异步的 ReactDOM.createRoot<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#拓展-关于异步模式下的首次渲染链路" aria-label="拓展：关于异步模式下的首次渲染链路"><!---->拓展：关于异步模式下的首次渲染链路<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#fiber-架构一定是异步渲染吗" aria-label="Fiber 架构一定是异步渲染吗？"><!---->Fiber 架构一定是异步渲染吗？<!----></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="#三、render-阶段" aria-label="三、render 阶段"><!---->三、render 阶段<!----></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#拆解-reactdom-render-调用栈——render-阶段" aria-label="拆解 ReactDOM.render 调用栈——render 阶段"><!---->拆解 ReactDOM.render 调用栈——render 阶段<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#workinprogress-节点的创建" aria-label="workInProgress 节点的创建"><!---->workInProgress 节点的创建<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#beginwork-开启-fiber-节点创建过程" aria-label="beginWork 开启 Fiber 节点创建过程"><!---->beginWork 开启 Fiber 节点创建过程<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#childreconciler-处理-fiber-节点的幕后-操盘手" aria-label="ChildReconciler，处理 Fiber 节点的幕后“操盘手”"><!---->ChildReconciler，处理 Fiber 节点的幕后“操盘手”<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#fiber-节点的创建过程梳理" aria-label="Fiber 节点的创建过程梳理"><!---->Fiber 节点的创建过程梳理<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#fiber-树的构建过程" aria-label="Fiber 树的构建过程"><!---->Fiber 树的构建过程<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#循环创建新的-fiber-节点" aria-label="循环创建新的 Fiber 节点"><!---->循环创建新的 Fiber 节点<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#fiber-节点间是如何连接的呢" aria-label="Fiber 节点间是如何连接的呢"><!---->Fiber 节点间是如何连接的呢<!----></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="#四、commit-阶段" aria-label="四、commit 阶段"><!---->四、commit 阶段<!----></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="#completework——将-fiber-节点映射为-dom-节点" aria-label="completeWork——将 Fiber 节点映射为 DOM 节点"><!---->completeWork——将 Fiber 节点映射为 DOM 节点<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#completework-的工作原理" aria-label="completeWork 的工作原理"><!---->completeWork 的工作原理<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#completeunitofwork-——-开启收集-effectlist-的-大循环" aria-label="completeUnitOfWork —— 开启收集 EffectList 的“大循环”"><!---->completeUnitOfWork —— 开启收集 EffectList 的“大循环”<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#completeunitofwork-开启下一轮循环的原则" aria-label="completeUnitOfWork 开启下一轮循环的原则"><!---->completeUnitOfWork 开启下一轮循环的原则<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#副作用链-effectlist-的设计与实现" aria-label="副作用链（effectList）的设计与实现"><!---->副作用链（effectList）的设计与实现<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#render-阶段的工作目标是找出界面中需要处理的更新" aria-label="render 阶段的工作目标是找出界面中需要处理的更新"><!---->render 阶段的工作目标是找出界面中需要处理的更新<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="#commit-阶段工作流简析" aria-label="commit 阶段工作流简析"><!---->commit 阶段工作流简析<!----></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><p>原文链接: <a href="https://interview.poetries.top/principle-docs/react/19-ReactDOM.render%20%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%B2%E8%81%94%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E7%9A%84.html" target="_blank" rel="noopener noreferrer">https://interview.poetries.top/principle-docs/react/19-ReactDOM.render%20%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%B2%E8%81%94%E6%B8%B2%E6%9F%93%E9%93%BE%E8%B7%AF%E7%9A%84.html</a></p><p>从本讲开始，我们将以首次渲染为切入点，拆解 Fiber 架构下 <code>ReactDOM.render</code> 所触发的渲染链路，结合源码理解整个链路中所涉及的初始化、<code>render 和 commit</code> 等过程</p><h2 id="一、reactdom-render-调用栈的逻辑分层" tabindex="-1"><a class="header-anchor" href="#一、reactdom-render-调用栈的逻辑分层"><span>一、ReactDOM.render 调用栈的逻辑分层</span></a></h2><p>开篇先给到你一个简单的 React AppDemo：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">&quot;react-dom&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">          <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">              <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>我是标题<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span></span>
<span class="line">              <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第一段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span></span>
<span class="line">              <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第二段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line">          <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line">        <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">const</span> rootElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> rootElement<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Demo 启动后，渲染出的界面如下图所示：</p><p><img src="/images/s_poetries_work_images_20210501195335.png" alt=""></p><p>现在请你打开 Chrome 的 <code>Performance</code> 面板，点击下图红色圈圈所圈住的这个“记录”按钮：</p><p><img src="/images/s_poetries_work_images_20210501195353.png" alt=""></p><p>然后重新访问 Demo 页面对应的本地服务地址，待页面刷新后，终止记录，便能够得到如下图右下角所示的这样一个调用栈大图：</p><p><img src="/images/s_poetries_work_images_20210501195414.png" alt=""></p><p>放大该图，定位“<code>src/index.js</code>”这个文件路径，我们就可以找到 <code>ReactDOM.render</code> 方法对应的调用栈，如下图所示：</p><p><img src="/images/s_poetries_work_images_20210501195521.png" alt=""></p><p>从图中你可以看到，<code>ReactDOM.render</code> 方法对应的调用栈非常深，中间涉及的函数量也比较大。如果这张图使你心里发虚，请先不要急于撤退——分析调用栈只是我们理解渲染链路的一个手段，我们的目的是借此提取关键逻辑，而非理解调用栈中的每一个方法。就这张图来说，你首先需要把握的，就是整个调用链路中所包含的三个阶段</p><p><img src="/images/s_poetries_work_images_20210501195705.png" alt=""></p><p>图中 <code>scheduleUpdateOnFiber</code> 方法的作用是调度更新，在由 <code>ReactDOM.render</code> 发起的首屏渲染这个场景下，它触发的就是 <code>performSyncWorkOnRoot</code>。<code>performSyncWorkOnRoot</code> 开启的正是我们反复强调的 <strong>render 阶段</strong> ；而 <code>commitRoot</code> 方法开启的则是真实 DOM 的渲染过程（<strong>commit 阶段</strong> ）。因此以 <code>scheduleUpdateOnFiber</code> 和 <code>commitRoot</code> 两个方法为界，我们可以大致把 <code>ReactDOM.render</code> 的调用栈划分为三个阶段：</p><ul><li>初始化阶段</li><li><code>render</code> 阶段</li><li><code>commit</code> 阶段</li></ul><h2 id="二、初始化阶段" tabindex="-1"><a class="header-anchor" href="#二、初始化阶段"><span>二、初始化阶段</span></a></h2><h3 id="拆解-reactdom-render-调用栈——初始化阶段" tabindex="-1"><a class="header-anchor" href="#拆解-reactdom-render-调用栈——初始化阶段"><span>拆解 ReactDOM.render 调用栈——初始化阶段</span></a></h3><p>首先我们提取出初始化过程中涉及的调用栈大图：</p><p><img src="/images/s_poetries_work_images_20210501200309.png" alt=""></p><p>图中的方法虽然看上去又多又杂，但做的事情清清爽爽，那就是<code>完成 Fiber 树中基本实体的创建</code>。</p><p>什么是基本实体？基本实体有哪些？问题的答案藏在源码里，这里我为你提取了源码中的关键逻辑，首先是 <code>legacyRenderSubtreeIntoContainer</code> 方法。在 <code>ReactDOM.render</code> 函数体中，以下面代码所示的姿势调用了它：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">return</span> <span class="token function">legacyRenderSubtreeIntoContainer</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> element<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>而 <code>legacyRenderSubtreeIntoContainer</code> 的关键逻辑如下（解析在注释里）：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">function</span> <span class="token function">legacyRenderSubtreeIntoContainer</span><span class="token punctuation">(</span><span class="token parameter">parentComponent<span class="token punctuation">,</span> children<span class="token punctuation">,</span> container<span class="token punctuation">,</span> forceHydrate<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// container 对应的是我们传入的真实 DOM 对象</span></span>
<span class="line">      <span class="token keyword">var</span> root <span class="token operator">=</span> container<span class="token punctuation">.</span>_reactRootContainer<span class="token punctuation">;</span></span>
<span class="line">      <span class="token comment">// 初始化 fiberRoot 对象</span></span>
<span class="line">      <span class="token keyword">var</span> fiberRoot<span class="token punctuation">;</span></span>
<span class="line">      <span class="token comment">// DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root</span></span>
<span class="line">        root <span class="token operator">=</span> container<span class="token punctuation">.</span>_reactRootContainer <span class="token operator">=</span> <span class="token function">legacyCreateRootFromDOMContainer</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> forceHydrate<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot</span></span>
<span class="line">        fiberRoot <span class="token operator">=</span> root<span class="token punctuation">.</span>_internalRoot<span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">        <span class="token comment">// 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">          <span class="token keyword">var</span> originalCallback <span class="token operator">=</span> callback<span class="token punctuation">;</span></span>
<span class="line">          <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token function">getPublicRootInstance</span><span class="token punctuation">(</span>fiberRoot<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token function">originalCallback</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">          <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token comment">// Initial mount should not be batched.</span></span>
<span class="line">        <span class="token comment">// 进入 unbatchedUpdates 方法</span></span>
<span class="line">        <span class="token function">unbatchedUpdates</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">          <span class="token function">updateContainer</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> fiberRoot<span class="token punctuation">,</span> parentComponent<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致</span></span>
<span class="line">        fiberRoot <span class="token operator">=</span> root<span class="token punctuation">.</span>_internalRoot<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">          <span class="token keyword">var</span> _originalCallback <span class="token operator">=</span> callback<span class="token punctuation">;</span></span>
<span class="line">          <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token function">getPublicRootInstance</span><span class="token punctuation">(</span>fiberRoot<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token function">_originalCallback</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">          <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token comment">// Update</span></span>
<span class="line">    </span>
<span class="line">        <span class="token function">updateContainer</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> fiberRoot<span class="token punctuation">,</span> parentComponent<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token function">getPublicRootInstance</span><span class="token punctuation">(</span>fiberRoot<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我为你总结一下首次渲染过程中 <code>legacyRenderSubtreeIntoContainer</code> 方法的主要逻辑链路：</p><p><img src="/images/s_poetries_work_images_20210501201153.png" alt=""></p><p>在这个流程中，你需要关注到 <code>fiberRoot</code> 这个对象。<code>fiberRoot</code> 到底是什么呢？这里我将运行时的 <code>root 和 fiberRoot</code>为你截取出来，其中 root 对象的结构如下图所示：</p><p><img src="/images/s_poetries_work_images_20210501201231.png" alt=""></p><p>可以看出，root 对象（<code>container._reactRootContainer</code>）上有一个 <code>_internalRoot</code> 属性，这个 <code>_internalRoot</code> 也就是 <code>fiberRoot</code>。fiberRoot 的本质是一个 FiberRootNode 对象，其中包含一个 current 属性，该属性同样需要划重点。这里我为你高亮出 current 属性的部分内容：</p><p><img src="/images/s_poetries_work_images_20210501201327.png" alt=""></p><blockquote><p>或许你会对 <code>current</code> 对象包含的海量属性感到陌生和头大，但这并不妨碍你 Get 到“<code>current 对象是一个 FiberNode 实例</code>”这一点，<code>FiberNode</code>，正是 <code>Fiber</code> 节点对应的对象类型。<code>current</code> 对象是一个 <code>Fiber</code> 节点，不仅如此，它还是当前 <code>Fiber</code> 树的头部节点</p></blockquote><p>考虑到 <code>current</code> 属性对应的 <code>FiberNode</code> 节点，在调用栈中实际是由 <code>createHostRootFiber</code> 方法创建的，React 源码中也有多处以 <code>rootFiber</code> 代指 <code>current</code> 对象，因此下文中我们将以 <code>rootFiber 指代 current 对象</code>。</p><p>读到这里，你脑海中应该不难形成一个这样的指向关系：</p><p><img src="/images/s_poetries_work_images_20210501201544.png" alt=""></p><p>其中，<code>fiberRoot</code> 的关联对象是真实 <code>DOM</code> 的容器节点；而 <code>rootFiber</code> 则作为虚拟 DOM 的根节点存在。这两个节点，将是后续整棵 <code>Fiber</code> 树构建的起点。</p><p>接下来，<code>fiberRoot</code> 将和 <code>ReactDOM.render</code> 方法的其他入参一起，被传入 <code>updateContainer</code> 方法，从而形成一个回调。这个回调，正是接下来要调用的 <code>unbatchedUpdates</code> 方法的入参。我们一起看看 <code>unbatchedUpdates</code> 做了什么，下面代码是对 <code>unbatchedUpdates</code> 主体逻辑的提取：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">function</span> <span class="token function">unbatchedUpdates</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// 这里是对上下文的处理，不必纠结</span></span>
<span class="line">      <span class="token keyword">var</span> prevExecutionContext <span class="token operator">=</span> executionContext<span class="token punctuation">;</span></span>
<span class="line">      executionContext <span class="token operator">&amp;=</span> <span class="token operator">~</span>BatchedContext<span class="token punctuation">;</span></span>
<span class="line">      executionContext <span class="token operator">|=</span> LegacyUnbatchedContext<span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// finally 逻辑里是对回调队列的处理，此处不用太关注</span></span>
<span class="line">        executionContext <span class="token operator">=</span> prevExecutionContext<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>executionContext <span class="token operator">===</span> NoContext<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">          <span class="token comment">// Flush the immediate callbacks that were scheduled during this batch</span></span>
<span class="line">          <span class="token function">resetRenderTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">          <span class="token function">flushSyncCallbackQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>unbatchedUpdates</code> 函数体里，当下你只需要 Get 到一个信息：<code>它直接调用了传入的回调 fn</code>。而在当前链路中，fn 是什么呢？fn 是一个针对 <code>updateContainer</code> 的调用：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token function">unbatchedUpdates</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token function">updateContainer</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> fiberRoot<span class="token punctuation">,</span> parentComponent<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们很有必要去看看 <code>updateContainer</code> 里面的逻辑。这里我将主体代码提取如下（解析在注释里，如果没有耐心读完可以直接看文字解读）：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">function</span> <span class="token function">updateContainer</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> container<span class="token punctuation">,</span> parentComponent<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 这是一个 event 相关的入参，此处不必关注</span></span>
<span class="line">      <span class="token keyword">var</span> eventTime <span class="token operator">=</span> <span class="token function">requestEventTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">      <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 这是一个比较关键的入参，lane 表示优先级</span></span>
<span class="line">      <span class="token keyword">var</span> lane <span class="token operator">=</span> <span class="token function">requestUpdateLane</span><span class="token punctuation">(</span>current$1<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token comment">// 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新</span></span>
<span class="line">      <span class="token keyword">var</span> update <span class="token operator">=</span> <span class="token function">createUpdate</span><span class="token punctuation">(</span>eventTime<span class="token punctuation">,</span> lane<span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// update 的 payload 对应的是一个 React 元素</span></span>
<span class="line">      update<span class="token punctuation">.</span>payload <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token literal-property property">element</span><span class="token operator">:</span> element</span>
<span class="line">      <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback</span></span>
<span class="line">      callback <span class="token operator">=</span> callback <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> callback<span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">!==</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&#39;render(...): Expected the last optional `callback` argument to be a &#39;</span> <span class="token operator">+</span> <span class="token string">&#39;function. Instead received: %s.&#39;</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">          <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        update<span class="token punctuation">.</span>callback <span class="token operator">=</span> callback<span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 将 update 入队</span></span>
<span class="line">      <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>current$1<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token comment">// 调度 fiberRoot </span></span>
<span class="line">      <span class="token function">scheduleUpdateOnFiber</span><span class="token punctuation">(</span>current$1<span class="token punctuation">,</span> lane<span class="token punctuation">,</span> eventTime<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token comment">// 返回当前节点（fiberRoot）的优先级</span></span>
<span class="line">      <span class="token keyword">return</span> lane<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>updateContainer</code> 的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：</p><ul><li>请求当前 <code>Fiber</code> 节点的 lane（优先级）；</li><li>结合 <code>lane</code>（优先级），创建当前 <code>Fiber</code> 节点的 <code>update</code> 对象，并将其入队；</li><li>调度当前节点（<code>rootFiber</code>）。</li></ul><p>函数体中的 <code>scheduleWork</code> 其实就是 <code>scheduleUpdateOnFiber</code>，<code>scheduleUpdateOnFiber</code> 函数的任务是调度当前节点的更新。在这个函数中，会处理一系列与优先级、打断操作相关的逻辑。但是在 <code>ReactDOM.render</code> 发起的首次渲染链路中，这些意义都不大，因为这个渲染过程其实是同步的。我们可以尝试在 Source 面板中为该函数打上断点，逐行执行代码，会发现逻辑最终会走到下图的高亮处：</p><p><img src="/images/s_poetries_work_images_20210501211335.png" alt=""></p><p><code>performSyncWorkOnRoot</code>直译过来就是“执行根节点的同步任务”，<code>这里的“同步”二字需要注意，它明示了接下来即将开启的是一个同步的过程</code>。这也正是为什么在整个渲染链路中，调度（Schedule）动作没有存在感的原因。</p><p>前面我们曾经提到过，<code>performSyncWorkOnRoot</code> 是 <code>render</code> 阶段的起点，<code>render 阶段</code>的任务就是完成 <code>Fiber</code> 树的构建，它是整个渲染链路中最核心的一环。<code>在异步渲染的模式下，render 阶段应该是一个可打断的异步过程</code></p><blockquote><p>而现在，我相信你心里更多的疑惑在于：<code>都说 Fiber 架构带来的异步渲染是 React 16 的亮点，为什么分析到现在，竟然发现 ReactDOM.render 触发的首次渲染是个同步过程呢</code></p></blockquote><h3 id="同步的-reactdom-render-异步的-reactdom-createroot" tabindex="-1"><a class="header-anchor" href="#同步的-reactdom-render-异步的-reactdom-createroot"><span>同步的 ReactDOM.render，异步的 ReactDOM.createRoot</span></a></h3><p>其实在 React 16，包括近期发布的 React 17 小版本中，React 都有以下 3 种启动方式：</p><p><strong>legacy 模式：</strong></p><p><code>ReactDOM.render(&lt;App /&gt;, rootNode)</code>。这是当前 <code>React App</code> 使用的方式，当前没有计划删除本模式，但是这个模式可能不支持这些新功能。</p><p><strong>blocking 模式：</strong></p><p><code>ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code>。目前正在实验中，作为迁移到 <code>concurrent</code> 模式的第一个步骤</p><p><strong>concurrent 模式：</strong></p><p><code>ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code>。目前在实验中，未来稳定之后，打算作为 <code>React</code>的默认开发模式，这个模式开启了所有的新功能</p><blockquote><p>在这 3 种模式中，<code>我们常用的 ReactDOM.render 对应的是 legacy 模式，它实际触发的仍然是同步的渲染链路</code>。<code>blocking</code> 模式可以理解为 <code>legacy</code> 和 <code>concurrent</code>之间的一个过渡形态，之所以会有这个模式，是因为 React 官方希望能够提供渐进的迁移策略，帮助我们更加顺滑地过渡到 <code>Concurrent</code> 模式。<code>blocking</code> 在实际应用中是比较低频的一个模式，了解即可。</p></blockquote><p>按照官方的说法，“<code>长远来看，模式的数量会收敛，不用考虑不同的模式</code>，但就目前而言，模式是一项重要的迁移策略，让每个人都能决定自己什么时候迁移，并按照自己的速度进行迁移”。由此可以看出，<code>Concurrent 模式确实是 React 的终极目标</code>，也是其创作团队使用 Fiber 架构重写核心算法的动机所在。</p><h3 id="拓展-关于异步模式下的首次渲染链路" tabindex="-1"><a class="header-anchor" href="#拓展-关于异步模式下的首次渲染链路"><span>拓展：关于异步模式下的首次渲染链路</span></a></h3><p>当下，如果想要开启异步渲染，我们需要调用 <code>ReactDOM.createRoot</code> 方法来启动应用，那 <code>ReactDOM.createRoot</code> 开启的渲染链路与 <code>ReactDOM.render</code> 有何不同呢？</p><p>这里我修改一下调用方式，给你展示一下调用栈。由于本讲的源码取材于 React 17.0.0 版本，在这个版本中，<code>createRoot</code> 仍然是一个 <code>unstable</code> 的方法。因此实际调用的 API 应该是“<code>unstable_createRoot</code>”：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    ReactDOM<span class="token punctuation">.</span><span class="token function">unstable_createRoot</span><span class="token punctuation">(</span>rootElement<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>Concurrent</code> 模式开启后，首次渲染的调用栈变成了如下图所示的样子：</p><p><img src="/images/s_poetries_work_images_20210501212348.png" alt=""></p><p>乍一看，好像和 <code>ReactDOM.render</code> 差别很大，其实不然。图中 <code>createRoot</code> 所触发的逻辑仍然是一些准备性质的初始化工作，此处不必太纠结。关键在于下面我给你框出来的这部分，如下图所示</p><p><img src="/images/s_poetries_work_images_20210501212616.png" alt=""></p><p>我们拉近一点来看，如下图所示：</p><p><img src="/images/s_poetries_work_images_20210501212641.png" alt=""></p><p>你会发现这地方也调用了一个 <code>render</code>。再顺着这个调用往下看，发现有大量的熟悉面孔：<code>updateContainer</code>、<code>requestUpdateLane</code>、<code>createUpdate</code>、<code>scheduleUpdateOnFiber</code>......这些函数在 <code>ReactDOM.render</code> 的调用栈中也出现过。</p><p>其实，当前你看到的这个 <code>render</code> 调用链路，和 <code>ReactDOM.render</code> 的调用链路是非常相似的，主要的区别在 <code>scheduleUpdateOnFiber</code> 的这个判断里：</p><p><img src="/images/s_poetries_work_images_20210501212753.png" alt=""></p><p>在异步渲染模式下，由于请求到的 <code>lane</code> 不再是 <code>SyncLane</code>（同步优先级），故不会再走到 <code>performSyncWorkOnRoot</code> 这个调用，而是会转而执行 <code>else</code> 中调度相关的逻辑。</p><p>这里有个点要给你点出来——React 是如何知道当前处于哪个模式的呢？我们可以以 <code>requestUpdateLane</code> 函数为例，下面是它局部的代码：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">function</span> <span class="token function">requestUpdateLane</span><span class="token punctuation">(</span><span class="token parameter">fiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// 获取 mode 属性</span></span>
<span class="line">      <span class="token keyword">var</span> mode <span class="token operator">=</span> fiber<span class="token punctuation">.</span>mode<span class="token punctuation">;</span></span>
<span class="line">      <span class="token comment">// 结合 mode 属性判断当前的</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mode <span class="token operator">&amp;</span> BlockingMode<span class="token punctuation">)</span> <span class="token operator">===</span> NoMode<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> SyncLane<span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mode <span class="token operator">&amp;</span> ConcurrentMode<span class="token punctuation">)</span> <span class="token operator">===</span> NoMode<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token function">getCurrentPriorityLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> ImmediatePriority$1 <span class="token operator">?</span> SyncLane <span class="token operator">:</span> SyncBatchedLane<span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">      <span class="token keyword">return</span> lane<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中需要注意 <code>fiber</code>节点上的 <code>mode</code> 属性：<code>React 将会通过修改 mode 属性为不同的值，来标识当前处于哪个渲染模式；在执行过程中，也是通过判断这个属性，来区分不同的渲染模式</code>。</p><blockquote><p>因此不同的渲染模式在挂载阶段的差异，本质上来说并不是工作流的差异（其工作流涉及 初始化 → render → commit 这 3 个步骤），而是 mode 属性的差异。<code>mode 属性决定着这个工作流是一气呵成（同步）的，还是分片执行（异步）的</code></p></blockquote><h3 id="fiber-架构一定是异步渲染吗" tabindex="-1"><a class="header-anchor" href="#fiber-架构一定是异步渲染吗"><span>Fiber 架构一定是异步渲染吗？</span></a></h3><p><code>React 16</code> 如果没有开启 <code>Concurrent</code> 模式，那它还能叫 <code>Fiber</code> 架构吗？</p><p>从动机上来看，<code>Fiber 架构的设计确实主要是为了 Concurrent 而存在</code>。但经过了本讲紧贴源码的讲解，相信你也能够看出，在 React 16，包括已发布的 React 17 版本中，不管是否是 Concurrent，整个数据结构层面的设计、包括贯穿整个渲染链路的处理逻辑，已经完全用 Fiber 重构了一遍。站在这个角度来看，<code>Fiber 架构在 React 中并不能够和异步渲染画严格的等号，它是一种同时兼容了同步渲染与异步渲染的设计</code>。</p><h2 id="三、render-阶段" tabindex="-1"><a class="header-anchor" href="#三、render-阶段"><span>三、render 阶段</span></a></h2><h3 id="拆解-reactdom-render-调用栈——render-阶段" tabindex="-1"><a class="header-anchor" href="#拆解-reactdom-render-调用栈——render-阶段"><span>拆解 ReactDOM.render 调用栈——render 阶段</span></a></h3><p>首先，我们复习一下 <code>render 阶段</code>在整个渲染链路中的定位，如下图所示。</p><p><img src="/images/s_poetries_work_images_20210501214149.png" alt=""></p><p>图中，<code>performSyncWorkOnRoot</code> 标志着 <code>render 阶段</code>的开始，<code>finishSyncRender</code> 标志着 <code>render</code>阶段的结束。这中间包含了大量的 <code>beginWork</code>、<code>completeWork</code> 调用栈，正是 <code>render</code> 的工作内容。</p><blockquote><p><code>beginWork</code>、<code>completeWork</code> 这两个方法需要注意，它们串联起的是一个“模拟递归”的过程。</p></blockquote><p><code>React 15 下的调和过程是一个递归的过程</code>。而 <code>Fiber</code> 架构下的调和过程，虽然<code>并不是依赖递归来实现的</code>，但在 <code>ReactDOM.render</code> 触发的同步模式下，它仍然是一个<code>深度优先搜索</code>的过程。在这个过程中，<code>beginWork</code> 将创建新的 <code>Fiber</code> 节点，而 <code>completeWork</code> 则负责将 <code>Fiber</code> 节点映射为 <code>DOM</code> 节点。</p><p>我们的 Fiber 树都还长这个样子：</p><p><img src="/images/s_poetries_work_images_20210501214428.png" alt=""></p><p>就这么个样子，你遍历它，能遍历出来什么？到底怎么个遍历法？接下来我们就深入到源码里去一探究竟！</p><h3 id="workinprogress-节点的创建" tabindex="-1"><a class="header-anchor" href="#workinprogress-节点的创建"><span>workInProgress 节点的创建</span></a></h3><p><code>performSyncWorkOnRoot</code> 是 <code>render</code> 阶段的起点，而这个函数最关键的地方在于它调用了 <code>renderRootSync</code>。下面我们放大 <code>Performance</code> 调用栈，来看看 <code>renderRootSync</code> 被调用后，紧接着发生了什么：</p><p><img src="/images/s_poetries_work_images_20210501214533.png" alt=""></p><p>紧随其后的是 <code>prepareFreshStack</code>，这里不卖关子，<code>prepareFreshStack</code> 的作用是重置一个新的堆栈环境，其中最需要我们关注的步骤，就是对<code>createWorkInProgress</code> 的调用。以下我对 <code>createWorkInProgress</code> 的主要逻辑进行了提取（解析在注释里）：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token comment">// 这里入参中的 current 传入的是现有树结构中的 rootFiber 对象</span></span>
<span class="line">    <span class="token keyword">function</span> <span class="token function">createWorkInProgress</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token punctuation">,</span> pendingProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">var</span> workInProgress <span class="token operator">=</span> current<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span></span>
<span class="line">      <span class="token comment">// ReactDOM.render 触发的首屏渲染将进入这个逻辑</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 这是需要你关注的第一个点，workInProgress 是 createFiber 方法的返回值</span></span>
<span class="line">        workInProgress <span class="token operator">=</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> current<span class="token punctuation">.</span>key<span class="token punctuation">,</span> current<span class="token punctuation">.</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        workInProgress<span class="token punctuation">.</span>elementType <span class="token operator">=</span> current<span class="token punctuation">.</span>elementType<span class="token punctuation">;</span></span>
<span class="line">        workInProgress<span class="token punctuation">.</span>type <span class="token operator">=</span> current<span class="token punctuation">.</span>type<span class="token punctuation">;</span></span>
<span class="line">        workInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> current<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 这是需要你关注的第二个点，workInProgress 的 alternate 将指向 current</span></span>
<span class="line">        workInProgress<span class="token punctuation">.</span>alternate <span class="token operator">=</span> current<span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 这是需要你关注的第三个点，current 的 alternate 将反过来指向 workInProgress</span></span>
<span class="line">        current<span class="token punctuation">.</span>alternate <span class="token operator">=</span> workInProgress<span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// else 的逻辑此处先不用关注</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 以下省略大量 workInProgress 对象的属性处理逻辑</span></span>
<span class="line">      <span class="token comment">// 返回 workInProgress 节点</span></span>
<span class="line">      <span class="token keyword">return</span> workInProgress<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先要声明的是，该函数中的 <code>current</code> 入参指的是现有树结构中的 <code>rootFiber</code> 对象，如下图所示：</p><p><img src="/images/s_poetries_work_images_20210501214757.png" alt=""></p><p>源码太长（其实经过处理已经不长了）不看版的重点如下：</p><ul><li><code>createWorkInProgress</code> 将调用 <code>createFiber</code>，<code>workInProgress</code>是 <code>createFiber</code> 方法的返回值；</li><li><code>workInProgress</code> 的 <code>alternate</code> 将指向 <code>current</code>；</li><li><code>current</code> 的 <code>alternate</code> 将反过来指向 <code>workInProgress</code>。</li></ul><p>理解了这三点，你就会自然而然地想知道 <code>workInProgress</code> 的本体到底是什么样的，也就是 <code>createFiber</code> 到底会返回什么。下面我们就看看 <code>createFiber</code> 的逻辑：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">var</span> <span class="token function-variable function">createFiber</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> key<span class="token punctuation">,</span> mode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    </span>
<span class="line">      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FiberNode</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> key<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码出奇的简单，但信息却给得很到位 —— <code>createFiber 将创建一个 FiberNode 实例，而 FiberNode，它正是 Fiber 节点的类型</code>。因此 <code>workInProgress 就是一个 Fiber 节点</code>。不仅如此，细心的你可能还会发现 <code>workInProgress</code> 的创建入参其实来源于 <code>current</code>，如下面代码所示：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    workInProgress <span class="token operator">=</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>tag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> current<span class="token punctuation">.</span>key<span class="token punctuation">,</span> current<span class="token punctuation">.</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>workInProgress 节点其实就是 current 节点（即 rootFiber）的副本</strong></p><p>再结合 current 指向 rootFiber 对象（同样是 FiberNode 实例），以及 current 和 workInProgress 通过 alternate 互相连接这些信息，我们可以分析出这波操作执行完之后，整棵树的结构应该如下图所示：</p><p><img src="/images/s_poetries_work_images_20210501215239.png" alt=""></p><p>完成了这个任务之后，就会进入 workLoopSync 的逻辑。这个 workLoopSync 函数也是个“人狠话不多”的主，它的逻辑同样是简洁明了的，如下所示（解析在注释里）：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">function</span> <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// 若 workInProgress 不为空</span></span>
<span class="line">      <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 针对它执行 performUnitOfWork 方法</span></span>
<span class="line">        <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>workLoopSync</code> 做的事情就是通过 <code>while</code> 循环反复判断 <code>workInProgress</code> 是否为空，并在不为空的情况下针对它执行 <code>performUnitOfWork</code> 函数。</p><blockquote><p>而 <code>performUnitOfWork</code> 函数将触发对 <code>beginWork</code> 的调用，进而实现对新 <code>Fiber</code> 节点的创建。若 <code>beginWork</code> 所创建的 <code>Fiber</code> 节点不为空，则 <code>performUniOfWork</code> 会用这个新的 <code>Fiber</code> 节点来更新 <code>workInProgress</code> 的值，为下一次循环做准备。</p></blockquote><p><code>通过循环调用 performUnitOfWork 来触发 beginWork，新的 Fiber 节点就会被不断地创建</code>。当 <code>workInProgress</code> 终于为空时，说明没有新的节点可以创建了，也就意味着已经完成对整棵 <code>Fiber</code> 树的构建。</p><p>在这个过程中，<code>每一个被创建出来的新 Fiber 节点，都会一个一个挂载为最初那个 workInProgress 节点（如下图高亮处）的后代节点</code>。而上述过程中构建出的这棵 Fiber 树，也正是大名鼎鼎的 <code>workInProgress 树</code>。</p><p><img src="/images/s_poetries_work_images_20210501215505.png" alt=""></p><p>相应地，图中 current 指针所指向的根节点所在的那棵树，我们叫它“<code>current 树</code>”。</p><p>相应地，图中 current 指针所指向的根节点所在的那棵树，我们叫它“current 树”。</p><p>这时候，相信一些同学心里已经开始犯嘀咕了：一棵 current 树，一棵 workInProgress 树，这名堂也太多了吧！况且这两棵 Fiber 树至少在现在看来，是完全没区别的（毕竟都还只有一个根节点，哈哈）。React 这样设计的目的何在？或者换个问法——到底是什么样的事情一棵树做不到，非得搞两棵“一样”的树出来？</p><p>在一步一步理解 Fiber 树的构建和更新过程之后，我将带你去认识“两棵 Fiber 树”这一现象背后的动机。</p><p>接下来我们就深入到 <code>beginWork</code> 和 <code>completeWork</code> 的逻辑里去，一起看看 <code>Fiber</code> 树的构建过程及最终形态。</p><h3 id="beginwork-开启-fiber-节点创建过程" tabindex="-1"><a class="header-anchor" href="#beginwork-开启-fiber-节点创建过程"><span>beginWork 开启 Fiber 节点创建过程</span></a></h3><p>有一说一，beginWork 的源码实在是长到不科学。这里我们本着抓主要矛盾的原则，针对与树构建过程强相关的动作进行逻辑提取，代码如下（解析在注释里）：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">//  current 节点不为空的情况下，会加一道辨识，看看是否有更新逻辑要处理</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 获取新旧 props</span></span>
<span class="line">        <span class="token keyword">var</span> oldProps <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">var</span> newProps <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">        <span class="token comment">// 若 props 更新或者上下文改变，则认为需要&quot;接受更新&quot;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldProps <span class="token operator">!==</span> newProps <span class="token operator">||</span> <span class="token function">hasContextChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span></span>
<span class="line">         workInProgress<span class="token punctuation">.</span>type <span class="token operator">!==</span> current<span class="token punctuation">.</span>type <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">          <span class="token comment">// 打个更新标</span></span>
<span class="line">          didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>xxx<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">          <span class="token comment">// 不需要更新的情况 A</span></span>
<span class="line">          <span class="token keyword">return</span> <span class="token constant">A</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">          <span class="token keyword">if</span> <span class="token punctuation">(</span>需要更新的情况 <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">// 不需要更新的其他情况，这里我们的首次渲染就将执行到这一行的逻辑</span></span>
<span class="line">            didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">          <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        didReceiveUpdate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span> </span>
<span class="line">      <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">      <span class="token comment">// 这坨 switch 是 beginWork 中的核心逻辑，原有的代码量相当大</span></span>
<span class="line">      <span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">        <span class="token comment">// 这里省略掉大量形如&quot;case: xxx&quot;的逻辑</span></span>
<span class="line">        <span class="token comment">// 根节点将进入这个逻辑</span></span>
<span class="line">        <span class="token keyword">case</span> <span class="token literal-property property">HostRoot</span><span class="token operator">:</span></span>
<span class="line">          <span class="token keyword">return</span> <span class="token function">updateHostRoot</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span></span>
<span class="line">        <span class="token comment">// dom 标签对应的节点将进入这个逻辑</span></span>
<span class="line">        <span class="token keyword">case</span> <span class="token literal-property property">HostComponent</span><span class="token operator">:</span></span>
<span class="line">          <span class="token keyword">return</span> <span class="token function">updateHostComponent</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span></span>
<span class="line">    </span>
<span class="line">        <span class="token comment">// 文本节点将进入这个逻辑</span></span>
<span class="line">        <span class="token keyword">case</span> <span class="token literal-property property">HostText</span><span class="token operator">:</span></span>
<span class="line">          <span class="token keyword">return</span> <span class="token function">updateHostText</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">)</span></span>
<span class="line">        <span class="token operator">...</span><span class="token operator">...</span> </span>
<span class="line">        <span class="token comment">// 这里省略掉大量形如&quot;case: xxx&quot;的逻辑</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token comment">// 这里是错误兜底，处理 switch 匹配不上的情况</span></span>
<span class="line">      <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">          <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span></span>
<span class="line">            <span class="token string">&quot;Unknown unit of work tag (&quot;</span> <span class="token operator">+</span></span>
<span class="line">              workInProgress<span class="token punctuation">.</span>tag <span class="token operator">+</span></span>
<span class="line">              <span class="token string">&quot;). This error is likely caused by a bug in React. Please file an issue.&quot;</span></span>
<span class="line">          <span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>beginWork 源码太长不看版的重点总结</strong> ：</p><ul><li><code>beginWork</code> 的入参是一对用 <code>alternate</code> 连接起来的 <code>workInProgress</code> 和 <code>current</code> 节点；</li><li><code>beginWork</code> 的核心逻辑是根据 <code>fiber</code> 节点（<code>workInProgress</code>）的 <code>tag</code> 属性的不同，调用不同的节点创建函数。</li></ul><p>当前的 <code>current 节点是 rootFiber</code>，而 <code>workInProgress</code> 则是 <code>current 的副本</code>，它们的 <code>tag 都是 3</code>，如下图所示：</p><p><img src="/images/s_poetries_work_images_20210501215910.png" alt=""></p><p>而 <code>3</code> 正是 <code>HostRoot</code> 所对应的值，因此第一个 <code>beginWork</code> 将进入 <code>updateHostRoot</code> 的逻辑。</p><p>这里你先不必急于关注 <code>updateHostRoot</code> 的逻辑细节。事实上，在整段 <code>switch</code> 逻辑里，包含的形如“<code>update+类型名</code>”这样的函数是非常多的</p><p>幸运的是，这些函数之间不仅命名形式一致，工作内容也相似。就 render 链路来说，它们共同的特性，就是都会通过调用 reconcileChildren 方法，生成当前节点的子节点。</p><p>reconcileChildren 的源码如下：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">function</span> <span class="token function">reconcileChildren</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> renderLanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// 判断 current 是否为 null</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 若 current 为 null，则进入 mountChildFibers 的逻辑</span></span>
<span class="line">        workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">mountChildFibers</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 若 current 不为 null，则进入 reconcileChildFibers 的逻辑</span></span>
<span class="line">        workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> current<span class="token punctuation">.</span>child<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从源码来看，<code>reconcileChildren</code> 也只是做逻辑的分发，具体的工作还要到 <code>mountChildFibers</code> 和 <code>reconcileChildFibers</code> 里去看。</p><h3 id="childreconciler-处理-fiber-节点的幕后-操盘手" tabindex="-1"><a class="header-anchor" href="#childreconciler-处理-fiber-节点的幕后-操盘手"><span>ChildReconciler，处理 Fiber 节点的幕后“操盘手”</span></a></h3><p>那么这两个函数又是何方神圣呢？在源码中，我们可以觅得这样两个赋值语句：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">var</span> reconcileChildFibers <span class="token operator">=</span> <span class="token function">ChildReconciler</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">var</span> mountChildFibers <span class="token operator">=</span> <span class="token function">ChildReconciler</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>原来 <code>reconcileChildFibers</code> 和 <code>mountChildFibers</code> 不仅名字相似，出处也一致。它们都是 <code>ChildReconciler</code> 这个函数的返回值，仅仅存在入参上的区别。而 <code>ChildReconciler</code>，则是一个实打实的“庞然大物”，其内部的逻辑量堪比 <code>N</code> 个 <code>beginWork</code>。这里我将关键要素提取如下（解析在注释里）：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">function</span> <span class="token function">ChildReconciler</span><span class="token punctuation">(</span><span class="token parameter">shouldTrackSideEffects</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// 删除节点的逻辑</span></span>
<span class="line">      <span class="token keyword">function</span> <span class="token function">deleteChild</span><span class="token punctuation">(</span><span class="token parameter">returnFiber<span class="token punctuation">,</span> childToDelete</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">          <span class="token comment">// Noop.</span></span>
<span class="line">          <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> </span>
<span class="line">        <span class="token comment">// 以下执行删除逻辑</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">     </span>
<span class="line">      <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">    </span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 单个节点的插入逻辑</span></span>
<span class="line">      <span class="token keyword">function</span> <span class="token function">placeSingleChild</span><span class="token punctuation">(</span><span class="token parameter">newFiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects <span class="token operator">&amp;&amp;</span> newFiber<span class="token punctuation">.</span>alternate <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">          newFiber<span class="token punctuation">.</span>flags <span class="token operator">=</span> Placement<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> newFiber<span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 插入节点的逻辑</span></span>
<span class="line">      <span class="token keyword">function</span> <span class="token function">placeChild</span><span class="token punctuation">(</span><span class="token parameter">newFiber<span class="token punctuation">,</span> lastPlacedIndex<span class="token punctuation">,</span> newIndex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        newFiber<span class="token punctuation">.</span>index <span class="token operator">=</span> newIndex<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">          <span class="token comment">// Noop.</span></span>
<span class="line">          <span class="token keyword">return</span> lastPlacedIndex<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token comment">// 以下执行插入逻辑</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">      <span class="token comment">// 此处省略一系列 updateXXX 的函数，它们用于处理 Fiber 节点的更新</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 处理不止一个子节点的情况</span></span>
<span class="line">      <span class="token keyword">function</span> <span class="token function">reconcileChildrenArray</span><span class="token punctuation">(</span><span class="token parameter">returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">,</span> newChildren<span class="token punctuation">,</span> lanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token comment">// 此处省略一堆 reconcileXXXXX 形式的函数，它们负责处理具体的 reconcile 逻辑</span></span>
<span class="line">      <span class="token keyword">function</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span><span class="token parameter">returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">,</span> newChild<span class="token punctuation">,</span> lanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 这是一个逻辑分发器，它读取入参后，会经过一系列的条件判断，调用上方所定义的负责具体节点操作的函数</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 将总的 reconcileChildFibers 函数返回</span></span>
<span class="line">      <span class="token keyword">return</span> reconcileChildFibers<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于原本的代码量着实巨大，感兴趣的同学可以[点开这个文件查看细节 (opens new window)](https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react- reconciler/src/ReactChildFiber.old.js#L253)，此处我仅针对与主流程强相关的逻辑为你总结以下要点：</p><ul><li>关键的入参 <code>shouldTrackSideEffects</code>，意为“是否需要追踪副作用”，因此 <code>reconcileChildFibers</code> 和 <code>mountChildFibers</code> 的不同，在于对副作用的处理不同；</li><li><code>ChildReconciler</code> 中定义了大量如 <code>placeXXX、deleteXXX、updateXXX、reconcileXXX</code> 等这样的函数，这些函数覆盖了对 <code>Fiber</code> 节点的创建、增加、删除、修改等动作，将直接或间接地被 <code>reconcileChildFibers</code> 所调用；</li><li><code>ChildReconciler</code> 的返回值是一个名为 <code>reconcileChildFibers</code> 的函数，这个函数是一个逻辑分发器，它将根据入参的不同，执行不同的 Fiber 节点操作，最终返回不同的目标 Fiber 节点。</li></ul><p>对于第 1 点，这里展开说说。对副作用的处理不同，到底是哪里不同？以 placeSingleChild 为例，以下是 placeSingleChild 的源码：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">function</span> <span class="token function">placeSingleChild</span><span class="token punctuation">(</span><span class="token parameter">newFiber</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects <span class="token operator">&amp;&amp;</span> newFiber<span class="token punctuation">.</span>alternate <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        newFiber<span class="token punctuation">.</span>flags <span class="token operator">=</span> Placement<span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token keyword">return</span> newFiber<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，一旦判断 <code>shouldTrackSideEffects</code> 为 <code>false</code>，那么下面所有的逻辑都不执行了，直接返回。那如果执行下去会发生什么呢？简而言之就是给 Fiber 节点打上一个叫“flags”的标记，像这样：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    newFiber<span class="token punctuation">.</span>flags <span class="token operator">=</span> Placement<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个名为 flags 的标记有何作用呢？</p><p><strong>小科普：flags 是什么</strong></p><p>由于这里我引用的是 v17.0.0 版本的源码，属性名已经变更为 flags，但在更早一些的版本中，这个属性名叫“effectTag”。在时下的社区讨论中，effectTag 这个命名更常见，也更语义化，因此下文我将以 “effectTag”代指“flags”。</p><p><code>Placement</code> 这个 <code>effectTag</code> 的意义，<code>是在渲染器执行时，也就是真实 DOM 渲染时，告诉渲染器：我这里需要新增 DOM 节点</code>。 <code>effectTag 记录的是副作用的类型</code>，而所谓“副作用”，React 给出的定义是“数据获取、订阅或者修改 DOM”等动作。在这里，Placement 对应的显然是 DOM 相关的副作用操作。</p><p>像 <code>Placement 这样的副作用标识，还有很多，它们均以二进制常量的形式存在</code>，下图我为你截取了局部（你可以在这个文件里查看 <code>effectTag</code> 的类型）：</p><p><img src="/images/s_poetries_work_images_20210501220545.png" alt=""></p><p>回到我们的调用链路里来，由于 <code>current</code> 是 <code>rootFiber</code>，它不为 <code>null</code>，因此它将走入的是下图所高亮的这行逻辑。也就是说在 <code>mountChildFibers</code> 和 <code>reconcileChildFibers</code> 之间，它选择的是 <code>reconcileChildFibers</code>：</p><p><img src="/images/s_poetries_work_images_20210501220749.png" alt=""></p><p>结合前面的分析可知，<code>reconcileChildFibers</code> 是<code>ChildReconciler(true)</code>的返回值。入参为 <code>true</code>，意味着其内部逻辑是允许追踪副作用的，因此“打 <code>effectTag</code>”这个动作将会生效。</p><p>接下来进入 <code>reconcileChildFibers</code> 的逻辑，在 <code>reconcileChildFibers</code> 这个逻辑分发器中，会把 <code>rootFiber</code> 子节点的创建工作分发给 <code>reconcileXXX</code> 函数家族的一员——<code>reconcileSingleElement</code> 来处理，具体的调用形式如下图高亮处所示：</p><p><img src="/images/s_poetries_work_images_20210501220845.png" alt=""></p><p><code>reconcileSingleElement</code> 将基于 <code>rootFiber</code> 子节点的 <code>ReactElement</code> 对象信息，创建其对应的 FiberNode。这个过程中涉及的函数调用如下图高亮处所示：</p><p><img src="/images/s_poetries_work_images_20210501220908.png" alt=""></p><p>这里需要说明的一点是：<code>rootFiber 作为 Fiber 树的根节点</code>，它并没有一个确切的 <code>ReactElement</code> 与之映射。结合 <code>JSX</code> 结构来看，我们可以将其理解为是 <code>JSX</code> 中根组件的父节点。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">&quot;react-dom&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">          <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">              <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>我是标题<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span></span>
<span class="line">              <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第一段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span></span>
<span class="line">              <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第二段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line">          <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line">        <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">const</span> rootElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> rootElement<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，根组件是一个类型为 App 的函数组件，因此 <code>rootFiber 就是 App 的父节点</code>。</p><p>结合这个分析来看，图中的 <code>_created4</code> 是根据 <code>rootFiber</code> 的第一个子节点对应的 <code>ReactElement 来创建的 Fiber 节点</code>，那么它就是 App 所对应的 <code>Fiber</code> 节点。现在我为你打印出运行时的 <code>_created4</code> 值，会发现确实如此：</p><p><img src="/images/s_poetries_work_images_20210501221024.png" alt=""></p><p>App 所对应的 <code>Fiber</code> 节点，将被 <code>placeSingleChild</code> 打上“<code>Placement</code>”（新增）的副作用标记，而后作为 <code>reconcileChildFibers</code> 函数的返回值，返回给下图中的 <code>workInProgress.child</code>：</p><p><img src="/images/s_poetries_work_images_20210501221052.png" alt=""></p><p><code>reconcileChildren</code> 函数上下文里的 <code>workInProgress</code> 就是 <code>rootFiber</code> 节点。那么此时，我们就将新创建的 <code>App Fiber</code> 节点和 <code>rootFiber</code> 关联了起来，整个 <code>Fiber</code> 树如下图所示：</p><p><img src="/images/s_poetries_work_images_20210501221125.png" alt=""></p><h3 id="fiber-节点的创建过程梳理" tabindex="-1"><a class="header-anchor" href="#fiber-节点的创建过程梳理"><span>Fiber 节点的创建过程梳理</span></a></h3><p>分析完 <code>App FiberNode</code> 的创建过程，我们先不必急于继续往下走这个渲染链路。因为其实最关键的东西已经讲完了，剩余节点的创建只不过是对 <code>performUnitOfWork</code>、 <code>beginWork</code> 和 <code>ChildReconciler</code> 等相关逻辑的重复。</p><p>刚刚这一通分析所涉及的调用栈很长，相信不少人如果是初读的话，过程中肯定不可避免地要反复回看，确认自己现在到底在调用栈的哪一环。这里为了方便你把握逻辑脉络，我将本讲讲解的 beginWork 所触发的调用流程总结进一张大图：</p><p><img src="/images/s_poetries_work_images_20210501221222.png" alt=""></p><h3 id="fiber-树的构建过程" tabindex="-1"><a class="header-anchor" href="#fiber-树的构建过程"><span>Fiber 树的构建过程</span></a></h3><p>理解了 Fiber 节点的创建过程，就不难理解 Fiber 树的构建过程了。</p><p>前面我们已经锲而不舍地研究了各路关键函数的源码逻辑，此时相信你已经能够将函数名与函数的工作内容做到对号入座。这里我们不必再纠结与源码的实现细节，可以直接从工作流程的角度来看后续节点的创建。</p><h3 id="循环创建新的-fiber-节点" tabindex="-1"><a class="header-anchor" href="#循环创建新的-fiber-节点"><span>循环创建新的 Fiber 节点</span></a></h3><p>研究节点创建的工作流，我们的切入点是workLoopSync这个函数。</p><p>为什么选它？这里来复习一遍workLoopSync会做什么：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">function</span> <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// 若 workInProgress 不为空</span></span>
<span class="line">      <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 针对它执行 performUnitOfWork 方法</span></span>
<span class="line">        <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它会循环地调用 <code>performUnitOfWork</code>，而 <code>performUnitOfWork</code>，<code>其主要工作是“通过调用 beginWork，来实现新 Fiber 节点的创建”</code>；它还有一个次要工作，就是<code>把新创建的这个 Fiber 节点的值更新到 workInProgress 变量里去</code>。源码中的相关逻辑提取如下：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token comment">// 新建 Fiber 节点</span></span>
<span class="line">    next <span class="token operator">=</span> <span class="token function">beginWork$1</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> unitOfWork<span class="token punctuation">,</span> subtreeRenderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 将新的 Fiber 节点赋值给 workInProgress</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// If this doesn&#39;t spawn new work, complete the current work.</span></span>
<span class="line">      <span class="token function">completeUnitOfWork</span><span class="token punctuation">(</span>unitOfWork<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">      workInProgress <span class="token operator">=</span> next<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如此便能够确保每次 <code>performUnitOfWork</code> 执行完毕后，当前的 <code>workInProgress</code>都存储着下一个需要被处理的节点，从而为下一次的 <code>workLoopSync</code>循环做好准备。</p><p>现在我在 <code>workLoopSync</code> 内部打个断点，尝试输出每一次获取到的 <code>workInProgress</code> 的值，<code>workInProgress</code> 值的变化过程如下图所示：</p><p><img src="/images/s_poetries_work_images_20210501221423.png" alt=""></p><p>共有 7 个节点，若你点击展开查看每个节点的内容，就会发现这 7 个节点其实分别是：</p><ul><li><code>rootFiber</code>（当前 Fiber 树的根节点）</li><li><code>App FiberNode</code>（App 函数组件对应的节点）</li><li><code>class</code> 为 App 的 DOM 元素对应的节点，其内容如下图所示</li></ul><p><img src="/images/s_poetries_work_images_20210501221451.png" alt=""></p><p>class 为 <code>container</code> 的 DOM 元素对应的节点，其内容如下图所示</p><p><img src="/images/s_poetries_work_images_20210501221508.png" alt=""></p><p>h1 标签对应的节点</p><p>第 1 个 p 标签对应的 FiberNode，内容为“我是第一段话”，如下图所示</p><p><img src="/images/s_poetries_work_images_20210501221520.png" alt=""></p><p>第 2 个 p 标签对应的 FiberNode，内容为“我是第二段话”，如下图所示</p><p><img src="/images/s_poetries_work_images_20210501221536.png" alt=""></p><p>结合这 7 个 <code>FiberNode</code>，再对照对照我们的 Demo：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">          <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">              <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>我是标题<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span></span>
<span class="line">              <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第一段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span></span>
<span class="line">              <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第二段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line">          <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line">        <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>你会发现组件自上而下，每一个非文本类型的 ReactElement 都有了它对应的 Fiber 节点。</p></blockquote><p><strong>注：</strong> React 并不会为所有的文本类型 <code>ReactElement</code> 创建对应的 <code>FiberNode</code>，这是一种优化策略。是否需要创建 <code>FiberNode</code>，在源码中是通过<code>isDirectTextChild</code>这个变量来区分的</p><p>这样一来，我们构建的这棵树里，就多出了不少 FiberNode，如下图所示：</p><p><img src="/images/s_poetries_work_images_20210501221636.png" alt=""></p><p>Fiber 节点有是有了，但这些 Fiber 节点之间又是如何相互连接的呢？</p><h3 id="fiber-节点间是如何连接的呢" tabindex="-1"><a class="header-anchor" href="#fiber-节点间是如何连接的呢"><span>Fiber 节点间是如何连接的呢</span></a></h3><blockquote><p>不同的 Fiber 节点之间，将通过 <code>child、return、sibling</code> 这 3 个属性建立关系，其中 <code>child、return</code> 记录的是父子节点关系，而 <code>sibling</code> 记录的则是兄弟节点关系。</p></blockquote><p>这里我以 h1 这个元素对应的 Fiber 节点为例，给你展示下它是如何与其他节点相连接的。展开这个 Fiber 节点，对它的 child、 return、sibling 3 个属性作截取，如下图所示：</p><p>child 属性为 null，说明 h1 节点没有子 Fiber 节点：</p><p><img src="/images/s_poetries_work_images_20210501221716.png" alt=""></p><p>return 属性局部截图：</p><p><img src="/images/s_poetries_work_images_20210501221727.png" alt=""></p><p>sibling 属性局部截图：</p><p><img src="/images/s_poetries_work_images_20210501221737.png" alt=""></p><blockquote><p>可以看到，<code>return 属性指向的是 class 为 container 的 div 节点</code>，而 <code>sibling 属性指向的是第 1 个 p 节点</code>。结合 JSX 中的嵌套关系我们不难得知 ——<code>FiberNode 实例中，return 指向的是当前 Fiber 节点的父节点</code>，而 <code>sibling 指向的是当前节点的第 1 个兄弟节点</code>。</p></blockquote><p>结合这 3 个属性所记录的节点间关系信息，我们可以轻松地将上面梳理出来的新 FiberNode 连接起来：</p><p><img src="/images/s_poetries_work_images_20210501221811.png" alt=""></p><p>以上便是 <code>workInProgress Fiber</code> 树的最终形态了。从图中可以看出，虽然人们习惯上仍然将眼前的这个产物称为“Fiber 树”，但<code>它的数据结构本质其实已经从树变成了链表</code>。</p><p>注意，在分析 <code>Fiber</code> 树的构建过程时，我们选取了 <code>beginWork</code> 作为切入点，但整个 <code>Fiber</code> 树的构建过程中，并不是只有 <code>beginWork</code> 在工作。这其中，还穿插着 <code>completeWork</code> 的工作。只有将 <code>completeWork 和 beginWork</code> 放在一起来看，你才能够真正理解，<code>Fiber</code> 架构下的“深度优先遍历”到底是怎么一回事。</p><h2 id="四、commit-阶段" tabindex="-1"><a class="header-anchor" href="#四、commit-阶段"><span>四、commit 阶段</span></a></h2><p>实验 Demo 与前面保持一致，代码如下：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">&quot;react-dom&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">        <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">          <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;container&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>我是标题<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第一段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span></span>
<span class="line">            <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是第二段话<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span></span>
<span class="line">          <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line">        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></span>
<span class="line">      <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">const</span> rootElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> rootElement<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="completework——将-fiber-节点映射为-dom-节点" tabindex="-1"><a class="header-anchor" href="#completework——将-fiber-节点映射为-dom-节点"><span>completeWork——将 Fiber 节点映射为 DOM 节点</span></a></h3><p><strong>completeWork 的调用时机</strong></p><p>首先，我们先在调用栈中定位一下 <code>completeWork</code>。Demo 所对应的调用栈中，第一个 <code>completeWork</code> 出现在下图红框选中的位置：</p><p><img src="/images/s_poetries_work_images_20210502090820.png" alt=""></p><p>从图上我们需要把握住的一个信息是，从 <code>performUnitOfWork</code> 到 <code>completeWork</code>，中间会经过一个这样的调用链路：</p><p><img src="/images/s_poetries_work_images_20210502090847.png" alt=""></p><p>其中 <code>completeUnitOfWork</code> 的工作也非常关键，但眼下我们先拿 <code>completeWork</code> 开刀，你可以暂时将 <code>completeUnitOfWork</code> 简单理解为一个用于发起 <code>completeWork</code> 调用的“工具人”。<code>completeUnitOfWork</code> 是在 <code>performUnitOfWork</code> 中被调用的，那么 <code>performUnitOfWork</code> 是如何把握其调用时机的呢？我们直接来看相关源码（解析在注释里）：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">function</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span><span class="token parameter">unitOfWork</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">      <span class="token comment">// 获取入参节点对应的 current 节点</span></span>
<span class="line">      <span class="token keyword">var</span> current <span class="token operator">=</span> unitOfWork<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">      <span class="token keyword">var</span> next<span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>xxx<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token operator">...</span></span>
<span class="line">        <span class="token comment">// 创建当前节点的子节点</span></span>
<span class="line">        next <span class="token operator">=</span> <span class="token function">beginWork$1</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> unitOfWork<span class="token punctuation">,</span> subtreeRenderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token operator">...</span></span>
<span class="line">      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 创建当前节点的子节点</span></span>
<span class="line">        next <span class="token operator">=</span> <span class="token function">beginWork$1</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> unitOfWork<span class="token punctuation">,</span> subtreeRenderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 调用 completeUnitOfWork</span></span>
<span class="line">        <span class="token function">completeUnitOfWork</span><span class="token punctuation">(</span>unitOfWork<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 将当前节点更新为新创建出的 Fiber 节点</span></span>
<span class="line">        workInProgress <span class="token operator">=</span> next<span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段源码中你需要提取出的信息是：<code>performUnitOfWork 每次会尝试调用 beginWork 来创建当前节点的子节点，若创建出的子节点为空（也就意味着当前节点不存在子 Fiber 节点），则说明当前节点是一个叶子节点</code>。按照深度优先遍历的原则，当遍历到叶子节点时，“递”阶段就结束了，随之而来的是“归”的过程。因此这种情况下，就会调用 <code>completeUnitOfWork</code>，执行当前节点对应的 <code>completeWork</code> 逻辑。</p><p>接下来我们在 Demo 代码的 <code>completeWork</code> 处打上断点，看看第一个走到 <code>completeWork</code> 的节点是哪个，结果如下图所示：</p><p><img src="/images/s_poetries_work_images_20210502091049.png" alt=""></p><p>显然，第一个进入 <code>completeWork</code> 的节点是 <code>h1</code>，这也符合我们上一讲所构建出来的 <code>Fiber</code> 树中的节点关系，如下图所示：</p><p><img src="/images/s_poetries_work_images_20210502091118.png" alt=""></p><p>由图可知，按照深度优先遍历的原则，h1 确实将是第一个被遍历到的叶子节点。接下来我们就以 h1 为例，一起看看 completeWork 都围绕它做了哪些事情。</p><h3 id="completework-的工作原理" tabindex="-1"><a class="header-anchor" href="#completework-的工作原理"><span>completeWork 的工作原理</span></a></h3><p>这里仍然为你提取一下 <code>completeWork</code> 的源码结构和主体逻辑，代码如下（解析在注释里）：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">function</span> <span class="token function">completeWork</span><span class="token punctuation">(</span><span class="token parameter">current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// 取出 Fiber 节点的属性值，存储在 newProps 里</span></span>
<span class="line">      <span class="token keyword">var</span> newProps <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 根据 workInProgress 节点的 tag 属性的不同，决定要进入哪段逻辑</span></span>
<span class="line">      <span class="token keyword">switch</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">case</span> <span class="token operator">...</span><span class="token operator">...</span><span class="token operator">:</span></span>
<span class="line">          <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">case</span> <span class="token literal-property property">ClassComponent</span><span class="token operator">:</span></span>
<span class="line">          <span class="token punctuation">{</span></span>
<span class="line">            <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span>
<span class="line">          <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">case</span> <span class="token literal-property property">HostRoot</span><span class="token operator">:</span></span>
<span class="line">          <span class="token punctuation">{</span></span>
<span class="line">            <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">          <span class="token punctuation">}</span></span>
<span class="line">        <span class="token comment">// h1 节点的类型属于 HostComponent，因此这里为你讲解的是这段逻辑</span></span>
<span class="line">        <span class="token keyword">case</span> <span class="token literal-property property">HostComponent</span><span class="token operator">:</span></span>
<span class="line">          <span class="token punctuation">{</span></span>
<span class="line">            <span class="token function">popHostContext</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">var</span> rootContainerInstance <span class="token operator">=</span> <span class="token function">getRootHostContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">var</span> type <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>type<span class="token punctuation">;</span></span>
<span class="line">            <span class="token comment">// 判断 current 节点是否存在，因为目前是挂载阶段，因此 current 节点是不存在的</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> workInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">              <span class="token function">updateHostComponent$1</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> type<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> rootContainerInstance<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">              <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>ref <span class="token operator">!==</span> workInProgress<span class="token punctuation">.</span>ref<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token function">markRef$1</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">              <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">              <span class="token comment">// 这里首先是针对异常情况进行 return 处理</span></span>
<span class="line">              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newProps<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                  <span class="token punctuation">{</span></span>
<span class="line">                    <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">&quot;We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                  <span class="token punctuation">}</span></span>
<span class="line">                <span class="token punctuation">}</span> </span>
<span class="line">    </span>
<span class="line">                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">              <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">              <span class="token comment">// 接下来就为 DOM 节点的创建做准备了</span></span>
<span class="line">              <span class="token keyword">var</span> currentHostContext <span class="token operator">=</span> <span class="token function">getHostContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">              <span class="token comment">// _wasHydrated 是一个与服务端渲染有关的值，这里不用关注</span></span>
<span class="line">              <span class="token keyword">var</span> _wasHydrated <span class="token operator">=</span> <span class="token function">popHydrationState</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">              <span class="token comment">// 判断是否是服务端渲染</span></span>
<span class="line">              <span class="token keyword">if</span> <span class="token punctuation">(</span>_wasHydrated<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token comment">// 这里不用关注，请你关注 else 里面的逻辑</span></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">prepareToHydrateHostInstance</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> rootContainerInstance<span class="token punctuation">,</span> currentHostContext<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                  <span class="token function">markUpdate</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token comment">// 这一步很关键， createInstance 的作用是创建 DOM 节点</span></span>
<span class="line">                <span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token function">createInstance</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> rootContainerInstance<span class="token punctuation">,</span> currentHostContext<span class="token punctuation">,</span> workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token comment">// appendAllChildren 会尝试把上一步创建好的 DOM 节点挂载到 DOM 树上去</span></span>
<span class="line">                <span class="token function">appendAllChildren</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token comment">// stateNode 用于存储当前 Fiber 节点对应的 DOM 节点</span></span>
<span class="line">                workInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> instance<span class="token punctuation">;</span> </span>
<span class="line">    </span>
<span class="line">                <span class="token comment">// finalizeInitialChildren 用来为 DOM 节点设置属性</span></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">finalizeInitialChildren</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> type<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> rootContainerInstance<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                  <span class="token function">markUpdate</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">              <span class="token punctuation">}</span></span>
<span class="line">              <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">          <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">case</span> <span class="token literal-property property">HostText</span><span class="token operator">:</span></span>
<span class="line">          <span class="token punctuation">{</span></span>
<span class="line">            <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">          <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">case</span> <span class="token literal-property property">SuspenseComponent</span><span class="token operator">:</span></span>
<span class="line">          <span class="token punctuation">{</span></span>
<span class="line">            <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">          <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">case</span> <span class="token literal-property property">HostPortal</span><span class="token operator">:</span></span>
<span class="line">          <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">          <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">case</span> <span class="token literal-property property">ContextProvider</span><span class="token operator">:</span></span>
<span class="line">          <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">          <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">          <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Unknown unit of work tag (&quot;</span> <span class="token operator">+</span> workInProgress<span class="token punctuation">.</span>tag <span class="token operator">+</span> <span class="token string">&quot;). This error is likely caused by a bug in React. Please file an issue.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>试图捋顺这段 <code>completeWork</code> 逻辑，你需要掌握以下几个要点。</p><ul><li><code>completeWork</code> 的核心逻辑是一段体量巨大的 <code>switch</code>语句，在这段 <code>switch</code> 语句中，<code>completeWork</code> 将根据 <code>workInProgress</code> 节点的 <code>tag</code> 属性的不同，进入不同的 <code>DOM</code> 节点的创建、处理逻辑。</li><li>在 Demo 示例中，h1 节点的 tag 属性对应的类型应该是 HostComponent，也就是“原生 DOM 元素类型”。</li><li><code>completeWork</code> 中的 <code>current、 workInProgress</code> 分别对应的是下图中左右两棵 <code>Fiber</code> 树上的节点：</li></ul><p><img src="/images/s_poetries_work_images_20210502091323.png" alt=""></p><p>其中 workInProgress 树代表的是“当前正在 render 中的树”，而 current 树则代表“已经存在的树”。</p><p>workInProgress 节点和 current 节点之间用 alternate 属性相互连接。在组件的挂载阶段，current 树只有一个 rootFiber 节点，并没有其他内容。因此 h1 这个 workInProgress 节点对应的 current 节点是 null。</p><p>带着上面这些前提，再去结合注释读一遍上面提炼出来的源码，思路是不是就清晰多了？</p><p>捋顺思路后，我们直接来提取知识点。关于 completeWork，你需要明白以下几件事。</p><ul><li>用一句话来总结 <code>completeWork</code> 的工作内容：负责处理 Fiber 节点到 DOM 节点的映射逻辑。</li><li><code>completeWork</code> 内部有 3 个关键动作： <ul><li>创建<code>DOM</code> 节点（CreateInstance）</li><li>将 DOM 节点插入到 DOM 树中（AppendAllChildren）</li><li>为 DOM 节点设置属性（FinalizeInitialChildren）</li></ul></li><li>创建好的 DOM 节点会被赋值给 workInProgress 节点的 stateNode 属性。也就是说当我们想要定位一个 Fiber 对应的 DOM 节点时，访问它的 stateNode 属性就可以了。这里我们可以尝试访问运行时的 h1 节点的 stateNode 属性，结果如下图所示： <img src="/images/s_poetries_work_images_20210502091538.png" alt=""></li><li>将 DOM 节点插入到 DOM 树的操作是通过 <code>appendAllChildren</code> 函数来完成的</li></ul><p>说是将 DOM 节点插入到 DOM 树里去，实际上是将子 Fiber 节点所对应的 DOM 节点挂载到其父 Fiber 节点所对应的 DOM 节点里去。比如说在本讲 Demo 所构建出的 Fiber 树中，h1 节点的父结点是 div，那么 h1 对应的 DOM 节点就理应被挂载到 div 对应的 DOM 节点里去。</p><p>那么如果执行 appendAllChildren 时，父级的 DOM 节点还不存在怎么办？</p><p>比如 h1 节点作为第一个进入 completeWork 的节点，它的父节点 div 对应的 DOM 就尚不存在。其实不存在也没关系，反正 h1 DOM 节点被创建后，会作为 h1 Fiber 节点的 stateNode 属性存在，丢不掉的。当父节点 div 进入 appendAllChildren 逻辑后，会逐个向下查找并添加自己的后代节点，这时候，h1 就会被它的父级 DOM 节点“收入囊中”啦~</p><h3 id="completeunitofwork-——-开启收集-effectlist-的-大循环" tabindex="-1"><a class="header-anchor" href="#completeunitofwork-——-开启收集-effectlist-的-大循环"><span>completeUnitOfWork —— 开启收集 EffectList 的“大循环”</span></a></h3><p><code>completeUnitOfWork</code> 的作用是开启一个大循环，在这个大循环中，将会重复地做下面三件事：</p><ol><li>针对传入的当前节点，调用 completeWork，completeWork 的工作内容前面已经讲过，这一步应该是没有异议的；</li><li>将当前节点的副作用链（EffectList）插入到其父节点对应的副作用链（EffectList）中；</li><li>以当前节点为起点，循环遍历其兄弟节点及其父节点。当遍历到兄弟节点时，将 return 掉当前调用，触发兄弟节点对应的 performUnitOfWork 逻辑；而遍历到父节点时，则会直接进入下一轮循环，也就是重复 1、2 的逻辑。</li></ol><p>步骤 1 无须多言，接下来我将为你解读步骤 2 和步骤 3 的含义。</p><h3 id="completeunitofwork-开启下一轮循环的原则" tabindex="-1"><a class="header-anchor" href="#completeunitofwork-开启下一轮循环的原则"><span>completeUnitOfWork 开启下一轮循环的原则</span></a></h3><p>在理解副作用链之前，首先要理解 <code>completeUnitOfWork</code> 开启下一轮循环的原则，也就是步骤 3。步骤 3 相关的源码如下所示（解析在注释里）：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token keyword">do</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token operator">...</span><span class="token operator">...</span></span>
<span class="line">      <span class="token comment">// 这里省略步骤 1 和步骤 2 的逻辑 </span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 获取当前节点的兄弟节点</span></span>
<span class="line">      <span class="token keyword">var</span> siblingFiber <span class="token operator">=</span> completedWork<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 若兄弟节点存在</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>siblingFiber <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 将 workInProgress 赋值为当前节点的兄弟节点</span></span>
<span class="line">        workInProgress <span class="token operator">=</span> siblingFiber<span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 将正在进行的 completeUnitOfWork 逻辑 return 掉</span></span>
<span class="line">        <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span> </span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 若兄弟节点不存在，completeWork 会被赋值为 returnFiber，也就是当前节点的父节点</span></span>
<span class="line">      completedWork <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span> </span>
<span class="line">        <span class="token comment">// 这一步与上一步是相辅相成的，上下文中要求 workInProgress 与 completedWork 保持一致</span></span>
<span class="line">      workInProgress <span class="token operator">=</span> completedWork<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>completedWork <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>步骤 3 是整个循环体的收尾工作，它会在当前节点相关的各种工作都做完之后执行。</p><p>当前节点处理完了，自然是去寻找下一个可以处理的节点。我们知道，当前的 Fiber 节点之所以会进入 completeWork，是因为“递无可递”了，才会进入“归”的逻辑，这就意味着当前 Fiber 要么没有 child 节点、要么 child 节点的 completeWork 早就执行过了。因此 child 节点不会是下次循环需要考虑的对象，下次循环只需要考虑兄弟节点（siblingFiber）和父节点（returnFiber）。</p><p>那么为什么在源码中，遇到兄弟节点会 return，遇到父节点才会进入下次循环呢？这里我以 h1 节点的节点关系为例进行说明。请看下图：</p><p><img src="/images/s_poetries_work_images_20210502091827.png" alt=""></p><p>结合前面的分析和图示可知，h1 节点是递归过程中所触及的第一个叶子节点，也是其兄弟节点中被遍历到的第一个节点；而剩下的两个 p 节点，此时都还没有被遍历到，也就是说连 beginWork 都没有执行过。</p><p>因此对于 h1 节点的兄弟节点来说，当下的第一要务是回去从 beginWork 开始走起，直到 beginWork “递无可递”时，才能够执行 completeWork 的逻辑。beginWork 的调用是在 performUnitOfWork 里发生的，因此 completeUnitOfWork 一旦识别到当前节点的兄弟节点不为空，就会终止后续的逻辑，退回到上一层的 performUnitOfWork 里去。</p><p>接下来我们再来看 h1 的父节点 div：在向下递归到 h1 的过程中，div 必定已经被遍历过了，也就是说 div 的“递”阶段（ beginWork） 已经执行完毕，只剩下“归”阶段的工作要处理了。因此，对于父节点，completeUnitOfWork 会毫不犹豫地把它推到下一次循环里去，让它进入 completeWork 的逻辑。</p><p>值得注意的是，completeUnitOfWork 中处理兄弟节点和父节点的顺序是：先检查兄弟节点是否存在，若存在则优先处理兄弟节点；确认没有待处理的兄弟节点后，才转而处理父节点。这也就意味着，completeWork 的执行是严格自底向上的，子节点的 completeWork 总会先于父节点执行。</p><h3 id="副作用链-effectlist-的设计与实现" tabindex="-1"><a class="header-anchor" href="#副作用链-effectlist-的设计与实现"><span>副作用链（effectList）的设计与实现</span></a></h3><p>无论是 beginWork 还是 completeWork，它们的应用对象都是 workInProgress 树上的节点。我们说 render 阶段是一个递归的过程，“递归”的对象，正是这棵 workInProgress 树（见下图右侧高亮部分）：</p><p><img src="/images/s_poetries_work_images_20210502091913.png" alt=""></p><p>那么我们递归的目的是什么呢？或者说，render 阶段的工作目标是什么呢？</p><h3 id="render-阶段的工作目标是找出界面中需要处理的更新" tabindex="-1"><a class="header-anchor" href="#render-阶段的工作目标是找出界面中需要处理的更新"><span>render 阶段的工作目标是找出界面中需要处理的更新</span></a></h3><p>在实际的操作中，并不是所有的节点上都会产生需要处理的更新。比如在挂载阶段，对图中的整棵 workInProgress 递归完毕后，React 会发现实际只需要对 App 节点执行一个挂载操作就可以了；而在更新阶段，这种现象更为明显。</p><p>更新阶段与挂载阶段的主要区别在于更新阶段的 current 树不为空，比如说情况可以是下图这样子的：</p><p><img src="/images/s_poetries_work_images_20210502092000.png" alt=""></p><p>假如说我的某一次操作，仅仅对 p 节点产生了影响，那么对于渲染器来说，它理应只关注 p 节点这一处的更新。这时候问题就来了：怎样做才能让渲染器又快又好地定位到那些真正需要更新的节点呢？</p><p>在 render 阶段，我们通过艰难的递归过程来明确“p 节点这里有一处更新”这件事情。按照 React 的设计思路，render 阶段结束后，“找不同”这件事情其实也就告一段落了。commit 只负责实现更新，而不负责寻找更新，这就意味着我们必须找到一个办法能让 commit 阶段“坐享其成”，能直接拿到 render 阶段的工作成果。而这，正是副作用链（effectList）的价值所在。</p><p>副作用链（effectList） 可以理解为 render 阶段“工作成果”的一个集合：每个 Fiber 节点都维护着一个属于它自己的 effectList，effectList 在数据结构上以链表的形式存在，链表内的每一个元素都是一个 Fiber 节点。这些 Fiber 节点需要满足两个共性：</p><ul><li>都是当前 Fiber 节点的后代节点</li><li>都有待处理的副作用</li></ul><p>没错，Fiber 节点的 effectList 里记录的并非它自身的更新，而是其需要更新的后代节点。带着这个结论，我们再来品品小节开头 completeUnitOfWork 中的“步骤 2”：</p><blockquote><p>将当前节点的副作用链（effectList）插入到其父节点对应的副作用链（effectList）中。</p></blockquote><p>咱们前面已经分析过，“completeWork 是自底向上执行的”，也就是说，子节点的 completeWork 总是比父节点先执行。试想，若每次处理到一个节点，都将当前节点的 effectList 插入到其父节点的 effectList 中。那么当所有节点的 completeWork 都执行完毕时，我是不是就可以从“终极父节点”，也就是 rootFiber 上，拿到一个存储了当前 Fiber 树所有 effect Fiber的“终极版”的 effectList 了？</p><blockquote><p>把所有需要更新的 Fiber 节点单独串成一串链表，方便后续有针对性地对它们进行更新，这就是所谓的“收集副作用”的过程。</p></blockquote><p>这里我以挂载过程为例，带你分析一下这个过程是如何实现的。</p><p>首先我们要知道的是，这个 effectList 链表在 Fiber 节点中是通过 firstEffect 和 lastEffect 来维护的，如下图所示：</p><p><img src="/images/s_poetries_work_images_20210502092206.png" alt=""></p><p>其中 firstEffect 表示 effectList 的第一个节点，而 lastEffect 则记录最后一个节点。</p><p>对于挂载过程来说，我们唯一要做的就是把 App 组件挂载到界面上去，因此 App 后代节点们的 effectList 其实都是不存在的。effectList 只有在 App 的父节点（rootFiber）这才不为空。</p><p>那么 effectList 的创建逻辑又是怎样的呢？其实非常简单，只需要为 firstEffect 和 lastEffect 各赋值一个引用即可。以下是从 completeUnitOfWork 源码中提取出的相关逻辑（解析在注释里）：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line">    <span class="token comment">// 若副作用类型的值大于“PerformedWork”，则说明这里存在一个需要记录的副作用</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&gt;</span> PerformedWork<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// returnFiber 是当前节点的父节点</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>returnFiber<span class="token punctuation">.</span>lastEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 若父节点的 effectList 不为空，则将当前节点追加到 effectList 的末尾去</span></span>
<span class="line">        returnFiber<span class="token punctuation">.</span>lastEffect<span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> completedWork<span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 若父节点的 effectList 为空，则当前节点就是 effectList 的 firstEffect</span></span>
<span class="line">        returnFiber<span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> completedWork<span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">      <span class="token comment">// 将 effectList 的 lastEffect 指针后移一位</span></span>
<span class="line">      returnFiber<span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> completedWork<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码中的 flags 咱们已经反复强调过了，它旧时的名字叫“effectTag”，是用来标识副作用类型的；而“completedWork”这个变量，在当前上下文中存储的就是“正在被执行 completeWork 相关逻辑”的节点；至于“PerformedWork”，它是一个值为 1 的常量，React 规定若 flags（又名 effectTag）的值小于等于 1，则不必提交到 commit 阶段。因此 completeUnitOfWork 只会对 flags 大于 PerformedWork 的 effect fiber 进行收集。</p><p>结合这些信息，再去读一遍源码片段，相信你的理解过程就会很流畅了。这里我以 App 节点为例，带你走一遍 effectList 的创建过程：</p><ul><li>App FiberNode 的 flags 属性为 3，大于 PerformedWork，因此会进入 effectList 的创建逻辑；</li><li>创建 effectList 时，并不是为当前 Fiber 节点创建，而是为它的父节点创建，App 节点的父节点是 rootFiber，rootFiber 的 effectList 此时为空；</li><li>rootFiber 的 firstEffect 和 lastEffect 指针都会指向 App 节点，App 节点由此成为 effectList 中的唯一一个 FiberNode，如下图所示。</li></ul><p><img src="/images/s_poetries_work_images_20210502092259.png" alt=""></p><p>OK，读到这里，相信你已经对 effectList 的创建过程知根知底了。</p><p>现在，即便你对部分源码细节的消化可能没有那么快，也请你不要因为这些细节去中断自己串联整个渲染链路的思路。你只需要把握住“根节点（rootFiber）上的 effectList 信息，是 commit 阶段的更新线索”这个结论，就足以将 render 阶段和 commit 阶段串联起来。</p><h3 id="commit-阶段工作流简析" tabindex="-1"><a class="header-anchor" href="#commit-阶段工作流简析"><span>commit 阶段工作流简析</span></a></h3><p>在整个 ReactDOM.render 的渲染链路中，render 阶段是 Fiber 架构的核心体现，也是我们讲解的重点。对于 render 阶段，我对你的期望是“熟悉”，为了达成这个目标，我们对 render 阶段的学习还会再持续一个课时；而对于 commit 阶段，我只要求你做到“了解”。因此这里我会快速地带你过一遍 commit 阶段的重点知识，不占用你太多时间。</p><p>commit 会在 performSyncWorkOnRoot 中被调用，如下图所示：</p><p><img src="/images/s_poetries_work_images_20210502092337.png" alt=""></p><p>这里的入参 root 并不是 rootFiber，而是 fiberRoot（FiberRootNode）实例。fiberRoot 的 current 节点指向 rootFiber，因此拿到 effectList 对后续的 commit 流程来说不是什么难事。</p><p>从流程上来说，commit 共分为 3 个阶段：<code>before mutation、mutation、layout</code>。</p><ul><li>before mutation 阶段，这个阶段 DOM 节点还没有被渲染到界面上去，过程中会触发 getSnapshotBeforeUpdate，也会处理 useEffect 钩子相关的调度逻辑。</li><li>mutation，这个阶段负责 DOM 节点的渲染。在渲染过程中，会遍历 effectList，根据 flags（effectTag）的不同，执行不同的 DOM 操作。</li><li>layout，这个阶段处理 DOM 渲染完毕之后的收尾逻辑。比如调用 componentDidMount/componentDidUpdate，调用 useLayoutEffect 钩子函数的回调等。除了这些之外，它还会把 fiberRoot 的 current 指针指向 workInProgress Fiber 树。</li></ul><blockquote><p>关于 commit 阶段的实现细节，感兴趣的同学课下可以参阅 [commit 相关源码 (opens new window)](https://github.com/facebook/react/blob/a81c02ac150233bdb5f31380d4135397fb8f4660/packages/react- reconciler/src/ReactFiberWorkLoop.new.js)，这里不再展开讨论。对于 commit，如果你只能记住一个知识点，我希望你记住<code>它是一个绝对同步的过程</code>。<code>render 阶段可以同步也可以异步，但 commit 一定是同步的</code>。</p></blockquote><p>阅读全文</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: guoli@zhihu.com">guoli</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><div id="pwa-install"><!----><div id="install-modal-wrapper" style="display:none;"><div class="background"></div><div class="install-modal"><div class="header"><button type="button" class="close-button" aria-label="关闭"><svg xmlns="http://www.w3.org/2000/svg" class="icon close-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="close icon"><path d="M589.654 511.965 1007.212 84.22a49.777 49.777 0 0 0-.73-70.02 49.046 49.046 0 0 0-69.687.665L519.967 441.946 85.882 14.2a49.08 49.08 0 0 0-69.687.664 49.777 49.777 0 0 0 .664 70.019l433.454 427.082L16.859 939.048a49.777 49.777 0 0 0-.664 70.019 49.013 49.013 0 0 0 69.687.663l434.085-427.746 416.828 427.083A49.013 49.013 0 0 0 972.037 1024a48.416 48.416 0 0 0 34.512-14.27 49.777 49.777 0 0 0 .73-70.019z"></path></svg></button><div class="logo"><!----><div class="title"><h1></h1><p class="desc">该应用可以安装在你的 PC 或移动设备上。这将使该 Web 应用程序外观和行为与其他应用程序相同。它将在出现在应用程序列表中，并可以固定到主屏幕，开始菜单或任务栏。此 Web 应用程序还将能够与其他应用程序和你的操作系统安全地进行交互。</p></div></div></div><div class="content"><div class="highlight"><!----><!----></div><div class="description"><h3>详情</h3><p></p></div></div><div class="button-wrapper"><button type="button" class="install-button">安装<span></span></button><button type="button" class="cancel-button">取消</button></div></div></div></div><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-f2Cpj3V4.js" defer></script>
  </body>
</html>
